ğŸ’¼ CALISMA XXX

1- replication iÅŸlemleri gerÃ§ekleÅŸtirecek bir kullanÄ±cÄ± oluÅŸturulur.

psql -c "create role replicator with replication login password 'replicator'" ;

2- masterda pg_hba.conf iÃ§inde standby sunucusun ip si tanÄ±mlanÄ±r.

nano /pgdata/pg16/pg_hba.con

host    replication     replicator      standby_ip/32               scram-sha-256

2-  standby sunucuda pg_basebackup komutu ile master kopyasÄ±nÄ± alÄ±nmasÄ± iÅŸlemi baÅŸlatÄ±lÄ±r.

 /usr/lib/postgresql/17/bin/pg_basebackup -h master_ip -p 5432 -U replicator   -D /data/pg17_replika  -Xs -P -v --slot=ankara -C --checkpoint=fast -R


-Xs slot oluÅŸturma komutu.
-P ne kadar % ilerlediÄŸi basebackup
-R aldÄ±ÄŸÄ±mÄ±z basebackup standby moduna hazÄ±r hetirmiÅŸ oluyor. start an replica moduna Ã§alÄ±ÅŸmaya baÅŸÄ±yor


Replicator parolasÄ± girdikten sonra sÃ¼reÃ§ hata vermez ise aÅŸaÄŸÄ±daki gibi tamamlanacaktÄ±r.

Password: 
pg_basebackup: initiating base backup, waiting for checkpoint to complete
pg_basebackup: checkpoint completed
pg_basebackup: write-ahead log start point: 0/4000060 on timeline 1
pg_basebackup: starting background WAL receiver
pg_basebackup: created replication slot "ankara"
68033/68033 kB (100%), 1/1 tablespace                                         
pg_basebackup: write-ahead log end point: 0/4000138
pg_basebackup: waiting for background process to finish streaming ...
pg_basebackup: syncing data to disk ...
pg_basebackup: renaming backup_manifest.tmp to backup_manifest
pg_basebackup: base backup completed

3- Standby serverÄ±mÄ±zda postgresin bir kopyasÄ± hazÄ±r . Bu replikayÄ± baÅŸlatmak iÃ§in 


/usr/lib/postgresql/17/bin/pg_ctl start  -D /data/pg17_replika

komutu Ã§alÄ±ÅŸtÄ±rmak yeterli olacaktÄ±r.


4- Bir postgresql recovery moda olup olmadÄ±ÄŸÄ± kontrolu

 psql -c "select pg_is_in_recovery()"

sonucu 
True dÃ¶ner ise sunucu recovery modda sadece okumalar kabul eder.
false dÃ¶ner ise sunucu recovery modda deÄŸil yani yazmalarÄ± kabul eder. Streaming replica baÅŸarÄ±sÄ±z.

5- Bir sorun anÄ±nda standby Master rolÃ¼ne almak iÃ§in

standby Ã¼zerinde

select pg_promote();

yada 

pg_ctl promote -D /pgdata/pg16 

komutunun yÃ¼rÃ¼tÃ¼lmesi gerekir.

î€€
î€€-- aktif replikasyonlarÄ± listesi master Ã¼zerinde
î€€select * from pg_Stat_replication ;
î€€
select * from pg_replication_slots ;
î€€
î€€
-- Payten 725 ikinci gÃ¼n

sql Ã§Ä±ktÄ± ÅŸeklinde backup alacÄŸaÄ±mÄ±zda, pg_dump  , bir database alÄ±yordu. paralllik Ã¶zelliÄŸi

pg_dumpall tÃ¼m database cluster alÄ±yordu. ama parallelik Ã¶zelliÄŸi yoktu. genelde kullanÄ±clar ve iskelet yapasÄ±nÄ± almak iÃ§in kullanÄ±yoruz.


-- log -shipping ,    archiver

pitr iÅŸlemi gerÃ§keleÅŸtirmek iÃ§in, elimizde wal dosyalarÄ±n arÅŸivinin kesintisiz / eksiksiz olmasÄ± lazÄ±m. ayrÄ±nca full backup (pg_basebackup) ihtiyacÄ±mÄ±z.

archive_mode = on 

archive_command = ,  her 16 mb wal dosyasÄ± dolduktan sonra switch olduÄŸunda. archive_mode komut tetikleniyor.  echo 'profelis',

archive_command = 'test ! -f /mnt/server/archivedir/%f && cp %p /mnt/server/archivedir/%f'  

archive_mode aÃ§Ä±ldÄ±ÄŸÄ±na bir tehlike, archive_command baÅŸarÄ±lÄ± Ã§alÄ±ÅŸmaz ise, wal dosyalarÄ± recyle olmuyor. archive command baÅŸarÄ±lÄ± Ã§alÄ±ÅŸmasÄ±nÄ± bekliyor.

/*
2ï¸âƒ£ Streaming replication  , streaming protokol, master (wal_sender) , standby(wal_reciver) - read only

Streaming replication allows a standby server to stay more up-to-date than is possible with file-based log shipping. The standby connects to the primary, which streams WAL records to the standby as they're generated, without waiting for the WAL file to be filled.

ğŸ”¸ Log sihpping metodunda, wal dosyalarÄ±n dolmasÄ± beklenirken , streaming replication wal kayÄ±tlarÄ± yazÄ±ldÄ±kÃ§a beklemeden aktarÄ±mÄ± gerÃ§ekleÅŸir.

ğŸ”¸ bir Ã¶nceki konumuzda archiver log-shipping doÄŸasÄ± gereÄŸi async yapÄ±daydÄ±. streaming ise sync/async koÅŸulu saÄŸlayabiliyoruz.



master -> wal_level=replica, standby -> primary_conninfo , standby.signal

YapÄ±lacak iÅŸlemlerin Ã–zeti;
1. Master sunucuda standby ip izni dÃ¼zenlemesi gerÃ§ekleÅŸir.
2. Master sunucuda replikasyon iÅŸlemi iÃ§in kullanÄ±cÄ± oluÅŸturulur.
3. Standby sunucu Ã¼zerinde masterda kopya alma iÅŸlemi gerÃ§ekleÅŸtirilir.
4. Standby Ã¼zerinde primary_conninfo, standby.signal dÃ¼zenlenmesi yapÄ±lÄ±r.
5. Standby start verilir.


ğŸ’¼ CALISMA replikasyon 

1- replication iÅŸlemleri gerÃ§ekleÅŸtirecek bir kullanÄ±cÄ± oluÅŸturulur.

psql -c "create role replicator with replication login password 'replicator'" ;

2- masterda pg_hba.conf iÃ§inde standby sunucusun ip si tanÄ±mlanÄ±r.

nano /pgdata/pg16/pg_hba.con

host    replication     replicator      10.10.10.10/32               scram-sha-256


3-  standby sunucuda pg_basebackup komutu ile master kopyasÄ±nÄ± alÄ±nmasÄ± iÅŸlemi baÅŸlatÄ±lÄ±r.


/usr/lib/postgresql/17/bin/pg_basebackup -h 10.10.11.141 -p 5432 -U replicator   -D /data/pg17  -Xs -P -v --slot=ankara -C --checkpoint=fast -R

-- archive komutu iliÅŸkisi bulunmamakta.

-Xs slot oluÅŸturma komutu.
-P ne kadar % ilerlediÄŸi basebackup
-R aldÄ±ÄŸÄ±mÄ±z basebackup standby moduna hazÄ±r getirmiÅŸ oluyor. start an replica moduna Ã§alÄ±ÅŸmaya baÅŸÄ±yor. standby.signal, primary_conninfo
--slot , wal streaming yapÄ±lacak slotun ismi.

Replicator parolasÄ± girdikten sonra sÃ¼reÃ§ hata vermez ise aÅŸaÄŸÄ±daki gibi tamamlanacaktÄ±r.

/usr/lib/postgresql/16/bin/pg_ctl start  -D /pgdata/pg16

komutu Ã§alÄ±ÅŸtÄ±rmak yeterli olacaktÄ±r.

4- Bir postgresql recovery moda olup olmadÄ±ÄŸÄ± kontrolu

psql -c "select pg_is_in_recovery()" ;

wal_keep_size    
max_slot_wal_keep_size (500gb)

select * from pg_Stat_replication ;
select * from pg_replication_slots ;

11:15 kadar ara

5- Bir sorun anÄ±nda standby Master rolÃ¼ne almak iÃ§in

standby Ã¼zerinde

select pg_promote();

yada 

pg_ctl promote -D /pgdata/pg16 

komutunun yÃ¼rÃ¼tÃ¼lmesi gerekir.


-- swithcover iÅŸlemi adÄ±mlarÄ±

1. master kapandÄ± 

2. standby promote yÃ¼rÃ¼ttÃ¼m.

3. eski_master ayaÄŸa kalktÄ±ÄŸÄ±nda. direk baÅŸlatmadÄ±m. Ã¶nce standby.signal

4. eski_master postgresq.auto.conf , primary_conninfo bilgisin eklenmesi

5. eski_master start kÃ¼meye standby katÄ±lacaktÄ±r.

select * from pg_stat_Replication;

garanti altÄ±na almak 
- master
pg_hba all_recejt
- master
select * from pg_stat_Replication;

Cascading replication

12:00 - 14:00


-- master Ã¼zerinde hba dÃ¼zenlenmesi.

-- standby Ã¼zerinde  
pg_basebackup masterÄ±n yedeÄŸini , basebackup ek parametreleri bu sayede standby hazÄ±r halde yedeÄŸe sahip oluyordurk.
sonrasÄ±nda yedeÄŸe start verdiÄŸimiz vakit. replika ÅŸeklinde kalkÄ±yor.

/*---------------------------------------------------------------------
ğŸŒ https://www.postgresql.org/docs/current/runtime-config-replication.html
â­•ï¸ Streaming replikasyon parametreleri
--------------------------------------------------------------------
-- Replika kÃ¼melerinde nodelarÄ±n Ã¼stlenebileceÄŸi 4 farklÄ±.
19.6.1. Sending Servers
19.6.2. Primary Server
19.6.3. Standby Servers
19.6.4. Subscribers

-- max_wal_senders (integer) default:10

EÅŸ zamanlÄ± gerÃ§ekleÅŸek wal_sender limitini belirler.
Replica (standby) node sayÄ±sÄ±na eÅŸit yada fazla olmasÄ± gerekir.

Ã¶rn,  20 standby var ise, max_wal_sender en az 20 olmasÄ±.

-- max_replication_slots default:10

Slotlu replikasyon sayÄ±sÄ±nÄ±n limiti.

-- wal_keep_size (integer) (varsayÄ±lan :0)  ğŸ’¥ğŸ’¥ğŸ’¥  --slotsuzlar
pg_wal dizininde tutulan wal dosyalarÄ±nÄ±n minumum boyutunu belirtir. Bu sayede
standbylardan biri dÃ¼ÅŸtÃ¼ÄŸÃ¼ durumda ve sonradan geri geldiÄŸinde aradaki farkÄ± buradaki
wal dosyalarÄ±nÄ± iÅŸleyerek kapatabilir. 

100gb tanÄ±mlarsam, her zaman pg_Wal dizininde 100gb wal dosyasÄ± bekleyecektir.

-- max_slot_wal_keep_size (integer) (varsayÄ±lan : 0 ) ğŸ’¥ğŸ’¥ğŸ’¥ --slot â˜¢ï¸â˜¢ï¸â˜¢ï¸

Slot ile baÅŸlatÄ±lan replikasyonlarda, eÄŸer slot Ã¼zerinden replika sunucuya WAL trafiÄŸi gerÃ§ekleÅŸmezse, pg_wal dizininde WAL dosyalarÄ± birikir; bu birikim, replika tekrar aktif olup WAL tÃ¼ketimine baÅŸlayana kadar devam eder. 

Bu nedenle, askÄ±da kalan veya kullanÄ±lmayan slotlarÄ±n pg_wal dizinini doldurmasÄ±nÄ± Ã¶nlemek iÃ§in bu parametre, tutulabilecek WAL dosyalarÄ±nÄ±n maksimum boyutunu belirlemek amacÄ±yla kullanÄ±lÄ±r.


--wal_sender_timeout (integer)

60 sn boyunca standby ulaÅŸÄ±lamaz olursa standbyÄ±n crash olduÄŸunu varsayÄ±larak replikasyon baÄŸlantÄ±sÄ±nÄ± sonlandÄ±rÄ±r.

Aradaki internet baÄŸlantÄ±sÄ± zayÄ±f ve sorunlu ise yÃ¼ksek ayarlanmasÄ± dÃ¼ÅŸÃ¼nÃ¼lebilir.


-- synchronized_standby_slots

logical replication slotlarÄ±nÄ±n switchover durumlarÄ±nda ayakta kalmasÄ±nÄ± saÄŸlar.


/*-------------------------------------------------------------------------------
ğŸŒ https://www.postgresql.org/docs/current/runtime-config-replication.html#RUNTIME-CONFIG-REPLICATION-PRIMARY
ğŸ”¶ 19.6.2. Primary Server 
----------------------------------------------------------------------

-- â­•ï¸ synchronous_standby_names default:null ğŸ’¥ğŸ’¥ğŸ’¥ğŸš¨ğŸš¨ğŸš¨

ğŸ”¸ Streaming Replication kullanan sistemlerde, hangi standby sunucularÄ±n senkron (synchronous) replikasyona dahil olacaÄŸÄ±nÄ± tanÄ±mlar. Bu parametre boÅŸ bÄ±rakÄ±lÄ±rsa tÃ¼m replikasyonlar asenkron (asynchronous) olur.


synchronous_standby_names= '*' ÅŸeklinde ayarlayabiliriz.

Bu ÅŸekilde standbylarÄ±n en az birinde, masterdaki yazma iÅŸlemi sonucu gerÃ§ekleÅŸen wal kaydÄ±nÄ± almasÄ± beklenir. Standby wal kaydÄ±nÄ± aldÄ±ktan sonra masterÄ± bilgilendirilir ve client iÅŸlemi (commit ) baÅŸarÄ±lÄ± olur. 

aynÄ± lokasyon 1 master 2 standby. 

ğŸš¨ Bu yapÄ±landÄ±rma, standby sunuculardan her zaman en az birinin gÃ¼ncel kalmasÄ±nÄ± ve veri kaybÄ± olmadan failover yapÄ±labilmesini saÄŸlar. 

â˜¢ï¸ EÄŸer master, standbylardan birinden geri dÃ¶nÃ¼ÅŸ alamaz ise, gelen yazma iÅŸlemleri beklemede kalacaktÄ±r.

â„¹ï¸ Bu sayede her zaman bir verinin en az iki farklÄ± server yazÄ±ldÄ±ÄŸÄ±nÄ± garantilemiÅŸ oluyoruz. MasterÄ±n sunucuda oluÅŸacak bir eriÅŸim sorununda , Master olmaya aday  production ortamÄ±mÄ±zÄ± kesintiye uÄŸratmayacak standby sunucu adayÄ±nÄ± garantilemiÅŸ oluyoruz.


[FIRST] num_sync ( standby_name [, ...] )
ANY num_sync ( standby_name [, ...] )
standby_name [, ...]

â„¹ï¸ show cluster_name; (standby_name)
varsayÄ±lan null olarak tanÄ±mlÄ±dÄ±r. postgresql.conf dosyasÄ±nda veya SQL istemciden ALTER SYSTEM ile tanÄ±mlanabilir ve deÄŸiÅŸikliÄŸin etkili olmasÄ± iÃ§in sunucunun yeniden baÅŸlatÄ±lmasÄ± gerekir â€” genellikle bir standby sunucusunun application_name deÄŸeri olarak tanÄ±mlanarak synchronous standby olarak seÃ§ilmesini saÄŸlamak amacÄ±yla kullanÄ±lÄ±r.


âœ¨ synchronous_standby_names='*'

Rastegele standbylarÄ±n en az birinde geri dÃ¶nÃ¼ÅŸ beklenir.


âœ¨ synchronous_standby_names=  FIRST 3 (ankara, adana, izmir, bursa) --
sync,
ilk 3 sunucu ankara, adana, izmir lokasyouna wal dosyasÄ± yazÄ±lÄ±p stadnby geri dÃ¶nÃ¼ÅŸ bekleyecektir. 

ankara down olduÄŸunda , adana,izmir,bursa

iki datancenter


dc-1  (istabnul)

master , standby -1 , standby -2 

dc2-2, (ankara)

standby-3 ,standby -4 ,standby -5 

synchronous_standby_names=  FIRST 2 (standby-3, standby -1, standby -4, standby -2 ,standby -5, master ) 

-- first 2 her zaman ilk iki tane standby yanÄ±t beklenecektir.

synchronous_standby_names=  any 2 (standby-3, standby -1, standby -4, standby -2 ,standby -5, master ) 

-- any 2 her zaman restgale iki tane standby yanÄ±t beklenecektir.

-- rapor sunucunuz, bu sunucuyu failover dahil etmek istemiyoruz.

synchronous_standby_names=  any 1 (standby -1 ,standby-2,master) 


ğŸŒ https://www.postgresql.org/docs/current/runtime-config-wal.html#GUC-SYNCHRONOUS-COMMIT
-- â­•ï¸ synchronous_commit

synchronous_standby_names wal dosyalarÄ±na yanÄ±t verme seviyesi belirliyor.

https://www.percona.com/blog/wp-content/uploads/2020/08/sychronous_commit-1.png

remote_apply (5)    crash-safe  (wal dosyasÄ± replikada diske yazÄ±ldÄ± ve oynatÄ±ldÄ±)
on (4)              crash-safe  (wal dosyasÄ± replikada diske yazÄ±ldÄ±) varsyayÄ±lan
remote_write(3)     data-loss   (wal dosyasÄ± replika aldÄ±)
local(2)		    data-loss   (wal dosyasÄ± lokale yazÄ±ldÄ±)
off (1)             local-data-loss  (wal dosyasÄ± lokale yazÄ±lmasÄ±ndan emin deÄŸiliz. )

âš ï¸ Table 19.1. synchronous_commit Modes tablosu Ã¼zerinde synchronous_commit crash durumunda nodelarÄ±n ayakta kalma durumlarÄ±na yer verilmiÅŸtir.
â˜¢ï¸ varsayÄ±lan on , bu seviyenin altÄ±na dÃ¼ÅŸÃ¼rÃ¼lmemesi Ã¶nerelir. crash sonrasÄ± sistem genelinde veri kaybÄ± oluÅŸmamasÄ± iÃ§in.

-- Seviyeler arasÄ± perfomans karÅŸÄ±laÅŸtÄ±rÄ±lmasÄ±.
https://www.enterprisedb.com/sites/default/files/blogs/table_2_synch_blog.png


/*-------------------------------------------------------------------------------
ğŸŒ https://www.postgresql.org/docs/current/runtime-config-replication.html#RUNTIME-CONFIG-REPLICATION-STANDBY
ğŸ”¶ 19.6.3. Standby Servers 
---------------------------------------------------------------------
buradaki parametreler standby.signal olursa dizinde yani recovery modda baÅŸlar ise aktif
olur. Postgresql buradaki parametreleri dikkata alÄ±r.

ğŸ”¸ primary_conninfo (string) 

Master sunucuya ait connection string bilgisi.
ğŸ¯ master sunucunun ip si deÄŸiÅŸtiÄŸi durumlarda manuel olarak buradaki ip deÄŸiÅŸtirilerek reload atmamÄ±z replika sÃ¼recinin kesintiye uÄŸramamasÄ± saÄŸlanabilir.

Bu rahatlÄ±ÄŸÄ± yapabilmeniz. wal_keep_size yeterli bÃ¼yÃ¼yklÃ¼te olmasÄ± lazÄ±m.

ğŸ”¸ primary_slot_name 

replikasyon baÄŸlantÄ±sÄ±nÄ± saÄŸlanacaÄŸÄ± slotu belirtmek iÃ§in.

ğŸ”¸ hot standby default: on

standby sunucunun select sorgularÄ±nÄ± kabul etmesi saÄŸlar. default aÃ§Ä±k durumdadÄ±r.

ğŸŒ https://www.postgresql.org/docs/current/hot-standby.html#HOT-STANDBY-CONFLICT
-- hot standby conflict konusu ayrÄ±ntÄ±lÄ± incelemek iÃ§in linke bakÄ±labilir.
1.Access Exclusive Lock Ã§akÄ±ÅŸmalarÄ±:
Master Ã¼zerinde LOCK, DROP, ALTER gibi DDL iÅŸlemleri yapÄ±lÄ±rsa, standby'daki tablolarÄ± okuyan sorgularla Ã§akÄ±ÅŸÄ±r.

2.Tablespace silinmesi (DROP TABLESPACE):
Master Ã¼zerinde tablespace silinirse, standby Ã¼zerinde o tablespace'i geÃ§ici dosyalar iÃ§in kullanan sorgularla Ã§akÄ±ÅŸÄ±r.

3.VeritabanÄ± silinmesi (DROP DATABASE):
Master Ã¼zerinde bir veritabanÄ± silinirse, standbyâ€™da o veritabanÄ±na baÄŸlÄ± oturumlarla Ã§akÄ±ÅŸÄ±r.

4.VACUUM temizlik kayÄ±tlarÄ± (WAL'den gelen):
Master'dan gelen VACUUM iÅŸlemi sonucu silinmiÅŸ satÄ±rlarÄ± gÃ¶ren snapshotâ€™lara sahip standby transaction'larÄ±yla Ã§akÄ±ÅŸÄ±r.

5.Sayfa eriÅŸimi Ã§akÄ±ÅŸmasÄ±:
VACUUM iÅŸleminin hedef sayfasÄ±na standby'daki bir sorgu eriÅŸiyorsa, Ã§akÄ±ÅŸma olur â€” veri gÃ¶rÃ¼nÃ¼r olmasa bile.


ğŸ”¸ max_standby_archive_delay default:30s , restore_command ile yapÄ±landÄ±rma
show max_standby_archive_delay; --30s 

 â€¢ When hot standby is active, this parameter determines how long the standby server should wait before canceling standby queries that conflict with about-to-be-applied WAL entries.
 â€¢ Standby Ã¼zerinde wal dosyasÄ± replay olmasÄ± iÃ§in oluÅŸabilecek maksimum lag sÃ¼resi 30s
 â€¢ 30s sonunda replay olmayÄ± engelleyen sorgular cancel olacaktÄ±r. 
 
ğŸ”¸max_standby_streaming_delay default: 30s
show max_standby_streaming_delay;
 â€¢ YukarÄ±daki parametre ile aynÄ± anlama geliyor. Streaming replikasyon olan ortamlarda gerÃ§ekleÅŸiyor.


âš ï¸ standby Ã¼zerinde Ã§alÄ±ÅŸan sorgularda ve loglarda bu ÅŸekilde hatalar gÃ¶zlemlenebilir. UygulamanÄ±n buna hazÄ±r olmasÄ± gerekir.
ERROR:  canceling statement due to conflict with recovery
DETAIL:  User was holding a relation lock for too long.

ERROR: canceling statement due to conflict with recovery
Detail: User query might have needed to see row versions that must be removed

âš ï¸ Bu parametreler yÃ¼ksek ayarlanabilir ama bu durumda, sorgular cancel olmadÄ±ÄŸÄ± iÃ§in belirtilen sÃ¼re kadar standbydaki verilerin gÃ¼ncelliÄŸi mastera gÃ¶re geride kalacaktÄ±r.

ğŸ¯ standby Ã¼zerinde conflict durumlarÄ±nÄ± gÃ¶rmek iÃ§in,
postgres=# select * from pg_stat_database_conflicts where datname='postgres';

-[ RECORD 1 ]------------+---------
datid                    | 5
datname                  | postgres
confl_tablespace         | 0
confl_lock               | 3
confl_snapshot           | 0
confl_bufferpin          | 0
confl_deadlock           | 0
confl_active_logicalslot | 0


ğŸ”¸ hot_standby_feedback: off

âš ï¸ Ã–nemli Ã¶lÃ§Ã¼de conflict durumlarÄ±nÄ± engellesede hala conflict durumlarÄ±n oluÅŸmasÄ± mÃ¼mkÃ¼ndÃ¼r.

ğŸ¯ Masterda Ã¼zerinde vacuum iÅŸlemi sonucu dead-tuple temizliÄŸi iÃ§in standby Ã¼zerinde bu dead-tuplelara eriÅŸen sorgular conflict durumunu tetikleyecektir sÃ¼re sonunda cancel olacaktÄ±r. SorgularÄ±n cancel olmadan Ã§alÄ±ÅŸmasÄ± iÃ§in hot_standby_feedback parametresi aÃ§Ä±larak Ã§alÄ±ÅŸmasÄ± saÄŸlanabilir.


ğŸ”¸ recovery_min_apply_delay :0 , geriden gelen standby

wal dosyalarÄ±n replay edilmesi iÃ§in geÃ§mesi gereken sÃ¼reyi belirtir. delaylÄ± replika planlanmasÄ±nda kullanÄ±lÄ±r.

Ã–rn. Sistemde yanlÄ±ÅŸ veri gÃ¼ncellemelerine karÅŸÄ± , yedekten dÃ¶nÃ¼ÅŸten daha hÄ±zlÄ± ÅŸekilde veriye eriÅŸecek standby sunucu bulundurulmasÄ± iÃ§in dÃ¼ÅŸÃ¼nÃ¼lebilir.

4 hour , 1day, 1 week gibi

âš ï¸ Synchronous replication is affected by this setting 
when synchronous_commit is set to remote_apply; 
every COMMIT will need to wait to be applied.
synchronous_commit = 'remote_apply'; durumu bu parametre ile Ã§akÄ±ÅŸmaktadÄ±r.


/*-------------------------------------------------------------------------------
ğŸŒ https://www.postgresql.org/docs/17/runtime-config-replication.html#RUNTIME-CONFIG-REPLICATION-SUBSCRIBER
ğŸ”¶ 19.6.4. Subscribers 
---------------------------------------------------------------------------------

ğŸ”¸ max_replication_slots: 10
KaÃ§ farklÄ± abonelik (subscription)  tanÄ±mÄ± yapÄ±lacaÄŸÄ±nÄ± belirler.

ğŸ”¸ max_logical_replication_workers: 4

logical replication kullanÄ±lacak paralel iÅŸlemler iÃ§in havuz.

ğŸ”¸ max_sync_workers_per_subscription: 2

initial data copy , veri kopyalama aÅŸamasÄ±nda kaÃ§ adet paralel tablo kopyalanmasÄ± 
gerÃ§ekleÅŸecek onu limitler.

ğŸ”¸ max_parallel_apply_workers_per_subscription: 2

Normal replikasyon sÃ¼recin kullanÄ±labilecek paralel worker sayÄ±sÄ±.

abonelik (subscription) streaming = parallel belirtilerek yapÄ±lmÄ±ÅŸ ise.


Klasik master - standby streaming replikasyonda database clusterÄ±n replikasÄ± gerÃ§ekleÅŸmektedir.

Sadece a veritabanÄ±  ya da t tablosunu ya da sadece ÅŸu kolonlarÄ± yada satÄ±rlarÄ± filtrelenmesini gerÃ§ekleÅŸtiremek istediÄŸimiz durumda bu esnekliÄŸi logical replication saÄŸlÄ±yor. 

/*-------------------------------------------------------------------------------
ğŸŒ https://www.postgresql.org/docs/17/logical-replication.html
â­•ï¸ Chapter 29. Logical Replication (publisher, subscriber)
-- PostgreSQL 10+ 
---------------------------------------------------------------------------------
ğŸ”¸Logical replikasyon, database cluster tamamÄ±nÄ±n yada belirli bÃ¶lÃ¼mlerin âš ï¸DATA DEÄÄ°ÅÄ°KLÄ°KLERÄ°NÄ°N baÅŸka bir postgres veritabanÄ±na gerÃ§ek zaman replikasyonunu saÄŸlar. 

ğŸ”¸Klasik replikasyondan gÃ¶re Ã§ok fazla esnekliÄŸe sahiptir. Tablo, satÄ±r , kolon bazÄ±nda, DML (update /delete / insert) iÅŸlemlerine gÃ¶re replika olacak datalar ÅŸekillendiriebilir.


ğŸ”¸ Klasik master - standby rolleri yerine
Publisher -  Subscriber  ÅŸeklinde tanÄ±m kullanÄ±lmaktadÄ±r.

ğŸ”¸Publisher			Verilerin Ã¼retildiÄŸi (gÃ¶nderen) sunucu.
ğŸ”¸Subscriber		Verilerin alÄ±ndÄ±ÄŸÄ± (alan) sunucu.

ğŸ”¸Publication		YayÄ±nlanacak tablolarÄ±n tanÄ±mlandÄ±ÄŸÄ± yapÄ±.
ğŸ”¸Subscription		YayÄ±nlara abone olan yapÄ±.

ğŸŒ https://github.com/eulerto/wal2json
Ã‡Ã¶zÃ¼mlenen wal kayÄ±tlarÄ±na Ã¶rnek olmasÄ± iÃ§in incelenebilir.


ğŸŒ https://www.postgresql.org/docs/17/logical-replication-quick-setup.html
â­•ï¸ Basit logical replication yapÄ±landÄ±rÄ±lmasÄ±




Ã‡AlÄ±ÅŸma logical setup

*/*/*/*/*/*/
-- Publisher (master)
-- Publisher sunucu wal_level seviyesi logical olmalÄ±. 
wal_level = logical   

-- DeÄŸil ise 
Show wal_level; 
alter system set wal_level to 'logical';
select pg_Reload_conf();

-- -- parametre deÄŸiÅŸiklik restart gerektiriyor.
select * from pg_settings where pending_restart is true;

-- Publisher (master)
create table users (c1 serial  , c2 text );

CREATE PUBLICATION pub_user FOR TABLE users;

-- subscriber (standby) database
CREATE SUBSCRIPTION sub_user CONNECTION 'dbname=postgres host=10.10.11.142 port=5433 user=logicaluser password=logicaluser' 
PUBLICATION pub_user;


select * from pg_stat_subscription_stats; 

select * from pg_stat_subscription;



























































































