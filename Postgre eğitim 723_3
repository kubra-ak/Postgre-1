
disk datalarÄ±m data_pagelerde tutuylor,   deÄŸiÅŸikliÄŸine uÄŸradÄ±ÄŸÄ±nda , dirty_page olarak
shared_buffer -> dirty_buffer  
mvcc -> update/delete iÅŸlemleri sonucu dead_tuple oluÅŸturuyor.  
dead_tuplarÄ±n temizleme iÅŸlemi , tekrarda kullanÄ±ma aÃ§Ä±lmasÄ± -> vacuum
vacuum sonucu Ã§ok fazla tablo tarafÄ±nda kullanÄ±mayacak tutuyorsa tablomuz -> bloat durumunu oluÅŸtuyordu.

*** vacuum full bloat giderbiliyorduk. ACCESS EXCLUSIVE  alÄ±yor, okume / yazma engelleniyor.

vacuum  table_name --> tabloda dead_tuple tekrardaz insert/update  iÃ§in kullanÄ±ma aÃ§Ä±lÄ±yor.okuma yazma engellenmiyor.


/*
â­•ï¸ Updating Planner Statistics

The PostgreSQL query planner relies on statistical information about the contents of tables
in order to generate good plans for queries.
These statistics are gathered by the ANALYZE command,
which can be invoked by itself or as an optional step in VACUUM.
It is important to have reasonably accurate statistics, 
otherwise poor choices of plans might degrade database performance.

ğŸ”¸ Postgres verileri diskte "HEAP TABLE" metodu olarak tuttuÄŸu iÃ§in veriler disk bloÄŸÄ±nda rastgele olarak daÄŸÄ±lmÄ±ÅŸ haldedir. Sorgu planyÄ±cÄ±sÄ±n aranan veriye en uygun eriÅŸimi yolunu belirler iken tabloya ait istatiksel bilgilerin gÃ¼ncel olmasÄ± , sorgu perfomansÄ± Ã§alÄ±ÅŸmasÄ± iÃ§in Ã¶nemlidir.

*/
select * from pg_stats where schemaname = 'public' --> tablolara ait istatistik  bilgileri gÃ¶rmek istediÄŸimizdeğŸ’¥ğŸ’¥ğŸ’¥
select * from pg_Statistic  --> tablo/index , kolon seviyesinde ait istatiksel bilgileri incelenmek 

/*
Autovacuum iÅŸlemi, autoanalyze iÅŸlemini gerÃ§ekleÅŸtirmektedir. BÃ¼yÃ¼k gÃ¼ncelleme yapÄ±lmÄ±ÅŸ ise tablo Ã¼zerinde autovacuum beklemek yerine manuel olarak ANALYZE table_name yÃ¼rÃ¼tÃ¼lebilir.

/*-------------------------------------------------------
ğŸŒ https://www.postgresql.org/docs/current/sql-analyze.html
â­•ï¸ ANALYZE Komutu
-------------------------------------------------------

ANALYZE, veritabanÄ±ndaki tablolarÄ±n iÃ§erikleri hakkÄ±nda istatistikler toplar 
ve bu verileri `pg_statistic` sistem kataloÄŸunda saklar. 
Daha sonra sorgu planlayÄ±cÄ±sÄ± (query planner), sorgular iÃ§in en verimli 
yÃ¼rÃ¼tme planÄ±nÄ± oluÅŸtururken bu istatistiklerden faydalanÄ±r.

*/*/
-- Ã–rnek kullanÄ±m:
ANALYZE test_analyze (c1); -- Sadece "c1" kolonu iÃ§in istatistik toplar


TRUNCATE TABLE test_analyze;
CREATE TABLE test_analyze (c1 int);

INSERT INTO test_analyze 
SELECT generate_series(1, 1000000);

INSERT INTO test_analyze 
SELECT generate_series(1000001, 2000000);  -- 1 milyon satÄ±r daha ekleniyor

-- Åu anda Ã¶lÃ¼ (dead) satÄ±r yok:
SELECT n_dead_tup 
FROM pg_stat_user_tables 
WHERE relname = 'test_analyze';  -- Beklenen: 0

-- Plan Ã§Ä±ktÄ±sÄ±nÄ± daha sade gÃ¶rebilmek iÃ§in paralel Ã§alÄ±ÅŸmayÄ± kapatÄ±yoruz
SET max_parallel_workers_per_gather = 0;


-- Toplam satÄ±r sayÄ±sÄ±nÄ± sorguluyoruz
EXPLAIN 
SELECT count(*) FROM test_analyze;

-- Plan:
-- Aggregate  (cost=37059.38..37059.39 rows=1 width=8)
--   ->  Seq Scan on test_analyze  (cost=0.00..31417.50 rows=ğŸ’¥2256750ğŸ’¥ width=0)

-- Tablodaki tÃ¼m verileri siliyoruz
DELETE FROM test_analyze; --> dead tuple
--truncate test analyze; --> gerÃ§ekten silinmiÅŸ oluyor. 

-- Sorgu planÄ± hala tabloda yaklaÅŸÄ±k 2 milyon satÄ±r olduÄŸunu varsayÄ±yor
EXPLAIN 
SELECT count(*) FROM test_analyze;

-- Plan:
-- Aggregate  (cost=37059.38..37059.39 rows=1 width=8)
--   ->  Seq Scan on test_analyze  (cost=0.00..31417.50 rows=2256750 width=0)

-- ANALYZE komutunu Ã§alÄ±ÅŸtÄ±rarak istatistikleri gÃ¼ncelliyoruz
ANALYZE test_analyze;

-- Sorguyu tekrar Ã§alÄ±ÅŸtÄ±rÄ±yoruz
EXPLAIN 
SELECT count(*) FROM test_analyze;

-- Yeni plan:
-- Aggregate  (cost=8850.00..8850.01 rows=1 width=8)
--   ->  Seq Scan on test_analyze  (cost=0.00..8850.00 rows=ğŸ’¥1ğŸ’¥ width=0)
-- ArtÄ±k planlayÄ±cÄ± tablonun boÅŸ olduÄŸunu biliyor



-- â­•ï¸  Updating the Visibility Map 

/**
Vacuum maintains a visibility map for each table to 
keep track of which pages contain only tuples that are known 
to be visible to all active transactions (and all future transactions, 
until the page is again modified). 

This has two purposes. 
First,  vacuum itself can skip such pages on the next run, since there is nothing to clean up.
Second, it allows PostgreSQL to answer some queries using only the index, 
without reference to the underlying table


ğŸ”¸ VACUUM iÅŸlemi gÃ¶ren her tablo iÃ§in bir Visibility Map (gÃ¶rÃ¼nÃ¼rlÃ¼k haritasÄ±) tutulur.
Bu VM dosyasÄ±nda, her veri sayfasÄ±nÄ±n (data page) iÃ§eriÄŸinde yer alan tuple'larÄ±n, tÃ¼m iÅŸlemler (transactions) tarafÄ±ndan gÃ¶rÃ¼nÃ¼r olup olmadÄ±ÄŸÄ±nÄ± takip eder.


ğŸ”¸ EÄŸer sayfadaki tÃ¼m tuple'lar tÃ¼m transactionlar iÃ§in gÃ¶rÃ¼nÃ¼r durumdaysa, ilgili sayfa Visibility Map Ã¼zerinde 1 olarak iÅŸaretlenir.

ğŸ”¸ EÄŸer sayfada yakÄ±n zamanda deÄŸiÅŸtirilmiÅŸ veya silinmiÅŸ (yani gÃ¶rÃ¼nÃ¼rlÃ¼ÄŸÃ¼ sÄ±nÄ±rlÄ±) tuple'lar varsa, bu durumda sayfa 0 olarak iÅŸaretlenir.

Bu mekanizma sayesinde:
ğŸ”¸ VACUUM, bir sonraki Ã§alÄ±ÅŸmasÄ±nda 1 olarak iÅŸaretli sayfalarÄ± atlayarak daha hÄ±zlÄ± Ã§alÄ±ÅŸÄ±r.
â„¹ï¸ Vacuum uÄŸrama sÄ±klÄ±ÄŸÄ± fazla ise tablodaki bakÄ±m iÅŸlemi kÄ±sa sÃ¼recektir.
ğŸ”¸ Ä°ndeks Ã¼zerinden ulaÅŸÄ±lan verilerde tabloya eriÅŸim olmadan hÄ±zlÄ±ca dÃ¶nÃ¼ÅŸ saÄŸlanÄ±r. random I/O iÅŸlemi daha az gerÃ§ekleÅŸir.  index-only-scans

ğŸŒ https://www.postgresql.org/docs/current/indexes-index-only-scans.html -- daha detaylÄ± inceleme

show data_directory;

-- bir tablodaki visible map durumunu gÃ¶rmek iÃ§in pg_class tablosundan yararlanabiliriz.relallvisible kolonu kaÃ§ edet data_pages gÃ¶rÃ¼nÃ¼r durumda olduÄŸunun adet bilgisi tutuyor.
*/
select n.nspname AS schema_name, relname,reltuples::bigint,relpages,relallvisible 
from pg_class c JOIN pg_namespace n ON c.relnamespace = n.oid
where relkind='r' and n.nspname='public'  order by relallvisible desc  limit 100;


index-only-scan Ã¶rn ek Ã¼zerinden gÃ¶relim
-- drop table test_index_only_scan ; 
create table test_index_only_scan (c1 int) ;
create index on  test_index_only_scan   (c1);

select n.nspname AS schema_name, relname,reltuples::bigint,relpages,relallvisible 
from pg_class c JOIN pg_namespace n ON c.relnamespace = n.oid
where relkind='r' and relname='test_index_only_scan' 
order by relallvisible desc  limit 100

insert into test_index_only_scan select generate_Series(1,1_000_000);

select n.nspname AS schema_name, relname,reltuples::bigint,relpages,relallvisible 
from pg_class c JOIN pg_namespace n ON c.relnamespace = n.oid
where relkind='r' and relname='test_index_only_scan' 
order by relallvisible desc  limit 100

-- relallvisible It is updated by VACUUM, ANALYZE, and a few DDL commands such as CREATE INDEX.

explain  --> sorgu planÄ±nÄ± Ã§Ä±kartÄ±yor.
analyze  --> sorguyu gerÃ§ekten Ã§alÄ±ÅŸtÄ±yor
select c1  from test_index_only_scan where c1 =500001

Bitmap Heap Scan on test_index_only_scan  (cost=199.88..9662.91 rows=11284 width=4) (actual time=0.036..0.046 rows=2 loops=1)
  Recheck Cond: (c1 = 500001)
  Heap Blocks: exact=2
  ->  Bitmap Index Scan on test_index_only_scan_c1_idx  (cost=0.00..197.06 rows=11284 width=0) (actual time=0.023..0.025 rows=2 loops=1)
        Index Cond: (c1 = 500001)
Planning Time: 0.072 ms
Execution Time: 0.074 ms

-- beklendiÄŸi  gibi index yÃ¶neliyor.


vacuum verbose test_index_only_scan ;


select n.nspname AS schema_name, relname,reltuples::bigint,relpages,relallvisible 
from pg_class c JOIN pg_namespace n ON c.relnamespace = n.oid
where relkind='r' and relname='test_index_only_scan' 
order by relallvisible desc  limit 100 --> relpages 4425, relallvisible 4425 


explain analyze 
select c1  from test_index_only_scan where c1 =500001

Index Only Scan using test_index_only_scan_c1_idx1 on test_index_only_scan  (cost=0.42..143.93 rows=5000 width=4) (actual time=0.013..0.016 rows=1 loops=1)
  Index Cond: (c1 = 500001)
  Heap Fetches: 0
Planning Time: 0.088 ms
Execution Time: 0.032 ms

VM tablosunun gÃ¼ncelliÄŸi indexlerimi , sorgularÄ±mÄ±zÄ± index-only-scan yÃ¶nelendiriyordur.
500001,  1 - 100 , 500 - 600 -> tablo Ã¼zerinde data_pages kontrol etmesi data_pages

ğŸ¯ index-only-scan yÃ¶nelimi saÄŸlanmasÄ± veriye en hÄ±zlÄ± eriÅŸim yÃ¶ntemidir. SorgularÄ±mÄ±zÄ± bu ÅŸekilde yÃ¶nelim olmasÄ± iÃ§in tablo Ã¼zerinde indeks yapÄ±landÄ±rmasÄ± ve bakÄ±m iÅŸlemleri yakÄ±ndan takip edilebilir.

/*
-- â­•ï¸  Preventing Transaction ID Wraparound Failures 

BakÄ±m iÅŸlemleri saÄŸlÄ±klÄ± yÃ¼rÃ¼yen bir veritabanÄ±nda bu sorun ile karÅŸÄ±laÅŸÄ±lmaz. 
Ama uzun sÃ¼re askÄ±da kalan baÄŸlantÄ±lar ve hiÃ§ vacuum freeze gÃ¶rmeyen tablolarda 
bu sorun ile karÅŸÄ±lamasÄ± mÃ¼mkÃ¼n olabilir.

-- https://www.postgresql.org/docs/current/functions-info.html
-- txid anlatÄ±mÄ±
*/
begin;
select txid_current();--> transaction yaptÄ±ÄŸÄ±mÄ±zda 

select txid_current_snapshot() ; --> veritatÄ±nÄ±n sahip olduÄŸumuz versiyonu

create table test1 (c1 int);
insert into test1 values (1);  --> xmin deÄŸerin transaction baÅŸÄ±nda almÄ±ÅŸ olduÄŸum id

select xmin,xmax,* from test1; --> xmin deÄŸerin transaction baÅŸÄ±nda almÄ±ÅŸ olduÄŸum id
insert into test1 values (1); 
select xmin,xmax,* from test1;

commit;

/*

PostgreSQL'in MVCC (Multi-Version Concurrency Control) yapÄ±sÄ±, satÄ±rlarÄ±n gÃ¶rÃ¼nÃ¼rlÃ¼ÄŸÃ¼nÃ¼ belirlemek iÃ§in iÅŸlem kimlikleri (XID) arasÄ±nda karÅŸÄ±laÅŸtÄ±rma yapar.

Bir satÄ±rÄ±n xmin deÄŸeri (eklenme XID'si), mevcut iÅŸlemin XIDâ€™sinden bÃ¼yÃ¼kse, bu satÄ±r gelecekte yazÄ±lmÄ±ÅŸ olarak kabul edilir ve iÅŸlem tarafÄ±ndan gÃ¶rÃ¼nmez olur.

Ancak PostgreSQL'de iÅŸlem IDâ€™leri 32 bit ile sÄ±nÄ±rlÄ±dÄ±r ve yaklaÅŸÄ±k 4 milyar iÅŸlemden sonra sayaÃ§ sÄ±fÄ±rlanarak yeniden baÅŸlar (wraparound).

Bu durumda, geÃ§miÅŸte yazÄ±lmÄ±ÅŸ bazÄ± satÄ±rlarÄ±n XIDâ€™leri yeni XID ile kÄ±yaslandÄ±ÄŸÄ±nda gelecekteymiÅŸ gibi gÃ¶rÃ¼nÃ¼r ve bu satÄ±rlar sorgularda gÃ¶rÃ¼nmez hale gelir.

ğŸ“Œ Bu bir veri kaybÄ± deÄŸildir, ama eriÅŸilemeyen veri anlamÄ±na gelir.

Ã–Rn. baÅŸa dÃ¶ndÃ¼ÄŸÃ¼ durumda  1000 txid alarak baÅŸlttÄ±ÄŸÄ±mÄ±z bir sorguda, daha Ã¶nce 1000 den bÃ¼yÃ¼k txid yapÄ±lan satÄ±rlarÄ±. 150000 (txid_row) < 150000 (txid_current). Buda veriler silinmiÅŸ gibi algÄ±lanmaya yol aÃ§acaktÄ±r.

-- ğŸ”¶ FREEZE Nedir? â€“ PostgreSQL'de SatÄ±rlarÄ± KalÄ±cÄ± Olarak GÃ¶rÃ¼nÃ¼r KÄ±lmak

â„¹ï¸ The reason that periodic vacuuming solves the problem is that VACUUM will mark rows as frozen.

Bu sorun vacuum iÅŸleminin satÄ±larÄ± "frozen" olarak iÅŸaretlemesi Ã¶nÃ¼ne geÃ§ilir. 
"frozen" tuplelar her zaman gÃ¶rÃ¼nÃ¼r durumdadÄ±r. txid karÅŸÄ±laÅŸtÄ±rmasÄ±na girmezler.

-- relfreozenxid en son ne zaman freeze iÅŸlemi olmuÅŸ
select relname,relminmxid,relfrozenxid,
age(relfrozenxid)::text::bigint as age   -- freeze iÅŸlemi gÃ¶ren tablonun yaÅŸÄ± 0 lanÄ±r.
from pg_class order by relfrozenxid::text::bigint desc limit 5 
*/

create table test_freeze (c1 int);
insert into test_freeze select generate_series(1,1_000_000);

select xmin, * from test_freeze limit 100

select relname,relminmxid,relfrozenxid,
age(relfrozenxid)::text::bigint as age   --  tablonun yaÅŸÄ± 1 
from pg_class where relname='test_freeze' order by relfrozenxid::text::bigint desc limit 5 

vacuum freeze test_freeze ; --> yaÅŸÄ± 0 lanacaktÄ±r.

select relname,relminmxid,relfrozenxid,
age(relfrozenxid)::text::bigint as age   --  tablonun yaÅŸÄ± 0 
from pg_class where relname='test_freeze' order by relfrozenxid::text::bigint desc limit 5 

/*
ğŸ¯ vacuum yada autovacuum iÅŸlemi sÄ±rasÄ±nda belirli bir eÅŸik aÅŸÄ±ldÄ±ÄŸÄ±nda ek olarak freeze komutu ile birlikte tetiklenir satÄ±larÄ± frozen durumuna getirir.

*/
-- bu limitlere bakacak olursak
select name,setting,short_desc from pg_settings 
where (name like '%freeze%' or name like '%failsafe%')
and  name like '%vacuum%' and name not like '%xact%'  
order by name ;

--vacuum_freeze_min_age	50_000_000	Minimum age at which VACUUM should freeze a table row.
--https://www.postgresql.org/docs/17/runtime-config-client.html#GUC-VACUUM-FREEZE-MIN-AGE
ğŸ”¸ freeze iÅŸlemi tetiklendiÄŸinde  vacuum_freeze_min_age bu parametre limiti kadar freeze iÅŸlemi gerÃ§ekÅŸecek satÄ±rlara

select relname,relminmxid,relfrozenxid,
age(relfrozenxid)::text::bigint as age   --  tablonun yaÅŸÄ± 70_000_000 > 50_000_000
from pg_class where relname='test_freeze' order by relfrozenxid::text::bigint desc limit 5


--vacuum_freeze_table_age	150_000_000	Age at which VACUUM should scan whole table to freeze tuples.
--https://www.postgresql.org/docs/17/runtime-config-client.html#GUC-VACUUM-FREEZE-TABLE-AGE
ğŸ”¸ normal vacuum komutu Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda freeze komutu tetiklenmesi iÃ§in limit
ğŸ”¸ vacuum iÅŸlemi freeze iÅŸleminide tetikler. frozen tuple olmayan satÄ±rlar. frozen tuple haline gelir. 
tuple_age > vacuum_freeze_min_age bÃ¼yÃ¼k olma kuralÄ±na gÃ¶re


select relname,relminmxid,relfrozenxid,
age(relfrozenxid)::text::bigint as age   --  tablonun yaÅŸÄ± 170_000_000 > 50_000_000
from pg_class where relname='test_freeze' order by relfrozenxid::text::bigint desc limit 5



--https://www.postgresql.org/docs/17/runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE
ğŸ”¸ autovacuum_freeze_max_age	200_000_000	Age at which to autovacuum a table to prevent transaction ID wraparound.

ğŸ”¸ autovacuum ile vacuum tetiklenidÄŸinde freeze komutunda tetiklenmesi iÃ§in limit
bu deÄŸer > normal kullanÄ±cÄ±n vacuum iÅŸleminden tetiklenmesinde bÃ¼yÃ¼ktÃ¼r. aynÄ± anda Ã§alÄ±ÅŸma ÅŸansÄ±nÄ± ortadan kaldÄ±rmak iÃ§in.

2_147_483_648
-- â˜¢ï¸ vacuum_failsafe_age	1_600_000_000	Age at which VACUUM should trigger failsafe to avoid a wraparound outage.

--https://www.postgresql.org/docs/17/runtime-config-client.html#GUC-VACUUM-FAILSAFE-AGE

ğŸ”¸ When the failsafe is triggered, any cost-based delay that is in effect will no longer be applied, further non-essential maintenance tasks (such as index vacuuming) are bypassed, and any Buffer Access Strategy in use will be disabled resulting in VACUUM being free to make use of all of shared buffers.

ğŸš¨ Bu sÄ±nÄ±ra yaklaÅŸÄ±lÄ±r ise postgres tÃ¼m kaynaklarÄ±nÄ± frozen iÅŸlemi gerÃ§ekleÅŸtirmek iÃ§in kullanÄ±r. 
vacuum iÅŸlemi tÃ¼m shared buffer kullanÄ±labilecek modda Ã§alÄ±ÅŸÄ±r. ğŸš¨

-- ğŸš¨ askÄ±da connection masterda ,standbylarda, uzun sÃ¼releri connection kalmamalÄ±
/*
Ã–zet;

VACUUM komutu sayesinde:

ğŸ”¹ Update veya delete iÅŸlemleri sonucu oluÅŸan dead_tuple kapladÄ±ÄŸÄ± disk alanÄ±nÄ± geri kazandÄ±rÄ±r. (VACUUM) 
ğŸ”¹ Ä°statistikleri gÃ¼ncelleyerek, sorgu planlayÄ±cÄ±sÄ±nÄ±n daha doÄŸru kararlar almasÄ±nÄ± ve sorgularÄ±n daha hÄ±zlÄ± Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlar. (ANALYZE)
ğŸ”¹ Visibility Map'i gÃ¼nceller, bu da index-only scan (sadece index kullanÄ±larak yapÄ±lan taramalar) taramasÄ±nÄ±n gerÃ§ekleÅŸmesini saÄŸlar. (VACUUM)
ğŸ”¹ Transaction ID sarmalanmasÄ± (wraparound) nedeniyle oluÅŸabilecek veri kaybÄ±nÄ± Ã¶nler. (FREEZE)


-- 24.1.6. The Autovacuum Daemon 

ğŸ”¸ PostgreSQL has an optional but highly recommended feature called ğŸš¨ autovacuum ğŸš¨,  
whose purpose is to automate the execution of VACUUM and ANALYZE commands.

ğŸ”¸ BakÄ±m sÃ¼reclerini arka planda yÃ¶neten yardÄ±mcÄ± processimiz autovacuum launcher, tablo Ã¼zerinde gerÃ§ekleÅŸen iÅŸlemler ile belirli eÅŸik deÄŸerler aÅŸÄ±ldÄ±ÄŸÄ±nda autovacuum launcher, ilgili tabloda vacuum/analyze sÃ¼recini tetikler. varsayÄ±lan olarak aÃ§Ä±ktÄ±r. â˜¢ï¸ kapatÄ±lmamasÄ± Ã¶nerilir. â˜¢ï¸

ğŸ”¸ Son vacuum iÅŸleminde beri tabloda oluÅŸan dead_tuples ya da gerÃ§ekleÅŸen insert satÄ±r sayÄ±sÄ±> tetiklenme deÄŸerinden bÃ¼yÃ¼k ise
autovacuum -> vacuum komutunu baÅŸlatÄ±r.


ğŸ”¸UPDATE ya da DELETE iÃ§in formÃ¼l   (dead tuple sayÄ±sÄ±na gÃ¶re son vacuum gÃ¶rdÃ¼ÄŸÃ¼nden beri)

vacuum threshold (dead tuple) >= vacuum base threshold  + vacuum scale factor * number of tuples

Dead tuple nasÄ±l oluÅŸuyordu. delete iÅŸlemi , update  iÅŸlemi sonrasÄ±


ğŸ”¸ insert olan satÄ±rlara dayalÄ± formÃ¼l  (insert sayÄ±sÄ±na gÃ¶re son vacuum gÃ¶rdÃ¼ÄŸÃ¼nden beri)

vacuum insert threshold >= vacuum base insert threshold + vacuum insert scale factor * number of tuples


ğŸ”¸ Bu deÄŸerler nereden geliyor ona bakacak olursak.

-- formÃ¼llerdeki deÄŸerlerin default ayarlarÄ± ÅŸu ÅŸekildedir.
select name,setting,short_desc 
from pg_settings 
where name like '%autovacuum%' and  (name like '%threshold%' or name like '%factor%');


ğŸ”¸ Bu deÄŸerlere gÃ¶re bir Ã¶rnek hesap yapmak gerekirse.

vacuum threshold (oluÅŸan dead_tuple sayÄ±sÄ±) >= 

vacuum base threshold (50) +  
vacuum scale factor (0.2) * 
number of tuples (pg_class.reltuples yada  pg_Stat_user_tables.n_live_tup gÃ¶receÄŸimiz deÄŸer.)

*/

select 50+0.2*10000 = 2050 --> bu satÄ±r sayÄ±sÄ±nda fazla n_dead_tup gerÃ§ekleÅŸir ise tetiklenecektir.


vacuum insert threshold >= 
vacuum base insert threshold (1000) + 
vacuum insert scale factor (0.2) * number of tuples (pg_Stat_user_tables.n_live_tup)





select (now()+ '1day'::interval*xid)::date,  "vacuum insert scale factor" , "vacuum base insert threshold"  , "gerÃ§ekeleÅŸen insert sonrasÄ± tablodaki satÄ±r sayÄ±sÄ±" ,
"tabloya yapÄ±lan insert satÄ±r sayÄ±sÄ±" , 
"vacuum base insert threshold" +"vacuum insert scale factor"*"gerÃ§ekeleÅŸen insert sonrasÄ± tablodaki satÄ±r sayÄ±sÄ±"  
as "vacuum tetiklenmesi gereken minumum gerÃ§ekleÅŸmesi gereken insert sayÄ±sÄ± son vacuumdan beri" ,

case when "tabloya yapÄ±lan insert satÄ±r sayÄ±sÄ±" > "vacuum base insert threshold" +"vacuum insert scale factor"*"gerÃ§ekeleÅŸen insert sonrasÄ± tablodaki satÄ±r sayÄ±sÄ±"  then 'tetiklendi'
else 'tetiklenemez' end 

from (
select  xid, "tabloya yapÄ±lan insert satÄ±r sayÄ±sÄ±" ,
sum ("tablomdaki baÅŸlangÄ±Ã§ satÄ±r sayÄ±sÄ±" + "tabloya yapÄ±lan insert satÄ±r sayÄ±sÄ±" )
over( order by xid ) as "gerÃ§ekeleÅŸen insert sonrasÄ± tablodaki satÄ±r sayÄ±sÄ±" ,"vacuum base insert threshold" ,"vacuum insert scale factor"
from (
select 
0 as "tablomdaki baÅŸlangÄ±Ã§ satÄ±r sayÄ±sÄ±",
1000  as "vacuum base insert threshold" ,
0.2 as "vacuum insert scale factor" ,
generate_series(0,10) as xid,
10000 as "tabloya yapÄ±lan insert satÄ±r sayÄ±sÄ±"
) t1 
) t1 



select 100_000_000 *0.2 , 20_000_000.0 

-- tabloya Ã¶zel ince ayar yapÄ±yorum.
ALTER TABLE IF EXISTS public.test SET (  autovacuum_vacuum_scale_factor = 0.0002 ); -- delete update etklinen satÄ±r sayÄ±sÄ±n eÅŸik
ALTER TABLE IF EXISTS public.test SET (  autovacuum_vacuum_insert_scale_factor = 0.0002 ); -- insert sayÄ±sÄ±nda tetiklenen eÅŸik

select 100_000_000 *0.0002 , tabloda 20_000 insert iÅŸlemi gerÃ§ekleÅŸtiÄŸinde 

--bu kolonlara yorum yapÄ±larak autovacuuum tetiklenemeye tablolarÄ± tespit edilerek 
--tablo Ã¶zelinde ayarlanmasÄ± lazÄ±m.
select  relname,n_live_tup,--tablodaki satÄ±r sayÄ±mÄ±z
		n_dead_tup, -- delete ve update sayÄ±sÄ± son vacuum beri
		n_mod_since_analyze, -- insert sayÄ±sÄ± son analizden beri
		n_ins_since_vacuum  -- insert sayÄ±sÄ± son vacuum beri
		,last_autovacuum,last_vacuum,last_autoanalyze --> en son ne zaman bakÄ±m iÅŸlemi gerÃ§ekleÅŸmiÅŸ.
from 	pg_stat_user_tables  limit 5 ;

 -- â“â“â“ Peki index bakÄ±mÄ± ne zaman gerÃ§ekleÅŸiyor hangi durumarlarda ihtiyaÃ§ duyuluyor. â“â“â“

/*
-- ğŸŒ https://www.postgresql.org/docs/current/sql-reindex.html Ã¼zerinden devam edilecek.

REINDEX [ ( option [, ...] ) ] { INDEX | TABLE | SCHEMA } [ CONCURRENTLY ] name
REINDEX [ ( option [, ...] ) ] { DATABASE | SYSTEM } [ CONCURRENTLY ] [ name ]

where option can be one of:

    CONCURRENTLY [ boolean ]
    TABLESPACE new_tablespace
    VERBOSE [ boolean ]

-- â˜¢ï¸ reindex iÅŸlemi blocking read and write operations (ACCESS EXCLUSIVE)
REINDEX INDEX my_index; -- bir index Ã¼zerinde reindex gerÃ§ekleÅŸtir.
REINDEX TABLE my_table; -- tablodaki her index Ã¼zerinde reindex gerÃ§ekleÅŸir.

-- CONCURRENTLY without blocking read and write operations
REINDEX TABLE CONCURRENTLY my_table; -- reindex iÅŸlemi ACCESS EXCLUVE lock koymadan gerÃ§ekleÅŸir.

ğŸ”¸DROP INDEX momentarily takes an ACCESS EXCLUSIVE lock on the parent table, blocking both writes and reads
ğŸ”¸CREATE INDEX locks out writes but not reads, block writes , allow reads
ğŸ”¸REINDEX is similar to a drop and recreate of the index in that the index contents are rebuilt from scratch.  
â˜¢ï¸ Concurrently kullanÄ±mÄ± olmaz ise block read/write.

â“ hangi durumlarda reindeks dÃ¼ÅŸÃ¼nlÃ¼meliyiz â“ 

ğŸ”¸An index has become â€œbloatedâ€,

Tablo Ã¼zerinde gerÃ§ekleÅŸen UPDATE ve DELETE iÅŸlemleri, tablonun data_page alanlarÄ±nda dead_tuple oluÅŸmasÄ±na neden olur. Bu Ã¶lÃ¼ satÄ±rlar, VACUUM iÅŸlemi ile temizlenerek tekrar kullanÄ±labilir hÃ¢le getirilir.

Benzer durum index page yapÄ±larÄ±nda da geÃ§erlidir. Ã‡Ã¼nkÃ¼ bir satÄ±r gÃ¼ncellendiÄŸinde veya silindiÄŸinde, bu satÄ±ra ait indeks girdileri de artÄ±k geÃ§ersiz hale gelir ve bu da indeks sayfalarÄ±nda dead tuple oluÅŸmasÄ±na yol aÃ§ar.

VACUUM iÅŸlemi, yalnÄ±zca tabloyu deÄŸil, indeksleri de kontrol eder. Yeterli sayÄ±da Ã¶lÃ¼ indeks tuple varsa, bu alanlarÄ± da temizler ve index sayfalarÄ±nÄ±n yeniden veri yazÄ±mÄ± iÃ§in uygun hale gelmesini saÄŸlar. Bu sayede indeksin gereksiz yere bÃ¼yÃ¼mesi (bloat) engellenir.

ğŸ¯ Vacuum komutunun INDEX_CLEANUP Ã¶zelliÄŸi default AUTO durumundadÄ±r. index tablosunda bloatÄ± Ã¶nlemeye yardÄ±mcÄ± olur. 

-- elimdeki bir test tablosunda vacuum iÅŸlemi gerÃ§ekleÅŸtirilmiÅŸ,  ek olarak vacuum index kontrolÃ¼ gerÃ§ekleÅŸtirerek %40 oranÄ±nda index pagelerinde dead_tuple tekrar kullanÄ±babilir hale getirmiÅŸ
vacuum verbose test;
index scan needed: 298454 pages from table (40.04% of total) had 67450237 dead item identifiers removed

â„¹ï¸ Tablonun boyutuna oranla Ã§ok fazla update / delete iÅŸlemi gerÃ§ekleÅŸtirildiÄŸinde. REINDEX concurrently ile autovacuum sÃ¼recine bu iÅŸlemi bÄ±rakmamak akÄ±llÄ±ca olacaktÄ±r.

â„¹ï¸ leaf Fragmentation dÃ¼ÅŸÃ¼k , avg_leaf_density > %50 bÃ¼yÃ¼k olmasÄ± beklenir.

leaf_fragmenteation yÃ¼ksek olmasÄ± iyi deÄŸildir.
indexâ€™in dallandÄ±ÄŸÄ±nÄ± ve gezilecek yolun uzadÄ±ÄŸÄ±nÄ± gÃ¶sterir.

MantÄ±ksal olarak yakÄ±n olan index deÄŸerleri, fiziksel olarak uzak sayfalarda tutulduÄŸuna iÅŸaret eder.

Bu da aynÄ± aralÄ±ktaki deÄŸerlere eriÅŸmek iÃ§in daha fazla sayfa (page) okunmasÄ± anlamÄ±na gelir.
daha Ã§ok I/O yÃ¼kÃ¼ oluÅŸturur.


*/
create table test_reindex (c1 int);
create index on test_reindex (c1); -- varsayÄ±lan btree

-- Veri ekleniyor
insert into test_reindex select generate_series(1,100_000);

select * from pg_indexes where tablename='test_reindex' limit 10  --> indexleri gÃ¶rmek iÃ§in 

create extension pgstattuple;
https://www.postgresql.org/docs/current/pgstattuple.html


select avg_leaf_density,leaf_fragmentation from pgstatindex('test_reindex_c1_idx') ;

-- avg_leaf_density: Sayfa baÅŸÄ±na ortalama doluluk oranÄ±. > %50'nin Ã¼zerinde olmasÄ± iyidir.
-- leaf_fragmentation: Sayfalar arasÄ±nda veri daÄŸÄ±lÄ±mÄ± ne kadar daÄŸÄ±nÄ±k? DÃ¼ÅŸÃ¼k olmasÄ± beklenir.

insert into test_reindex select generate_series(1,1000000);
select avg_leaf_density,leaf_fragmentation from pgstatindex('test_reindex_c1_idx') ;
90.06	0, --> parÃ§alanma yok.

insert into test_reindex select generate_series(1,1000000);
select avg_leaf_density,leaf_fragmentation from pgstatindex('test_reindex_c1_idx') ;
83.9	49.99 --> %50 oldu, Ã–rn. %50 %50 data eÅŸit bÃ¼yÃ¼klÃ¼kte, 1 deÄŸer iki farklÄ± index page Ã¼zerinde  yer alacaÄŸÄ± iÃ§in (adreslenmiÅŸ) leaf_fragmentation %50 yarÄ± yarÄ±ya farklÄ± yerlerde.


insert into test_reindex select generate_series(1,1000000);

select avg_leaf_density,leaf_fragmentation from pgstatindex('test_reindex_c1_idx') ;
74.83	33.33 --> %33 oldu, Ã–rn. datam Ã¼Ã§ eÅŸit bÃ¼yÃ¼klte daÄŸÄ±lmÄ±ÅŸ, 1 deÄŸer Ã¼Ã§ farklÄ± page yer alacaÄŸÄ± iÃ§in leaf_fragmentation %33 

reindex (verbose) table test_reindex;

select avg_leaf_density,leaf_fragmentation from pgstatindex('test_reindex_c1_idx') ;
90.09	0  fragmentation azaldÄ±.

-- index baÅŸtan yazÄ±lma (rewrite) iÅŸlemi gerÃ§ekleÅŸerek verileri mantÄ±ksal - fiziksel olarak korele hale geldi. 

-- ğŸ”¸An index has become corrupted, 

Bug ya da donanÄ±m arazÄ±larÄ± nedeniyle nadirde olsa gÃ¶rÃ¼lebilir.

-- Ã§alÄ±ÅŸan sorguda  ve loglarda gÃ¶zÃ¼kecek Ã¶rnek hata:
*/
WARNING:  page verification failed, calculated checksum 346 but expected 36611
ERROR:  invalid page in block 0 of relation base/16699/16723
/*

â„¹ï¸ base/16699/16723 (base/database_ID/rellfilenode) relation bilgileri ğŸ’¥indexe ait ise ğŸ¯ REINDEX yapÄ±larak corrupt index datasÄ± , verinin kendisinden tablodan tekrardan oluÅŸturulur.

select * from pg_Class where relfilenode=  limit 10 

â˜¢ï¸ deÄŸil ise yazÄ±lan veri corrupt olmuÅŸtur. Yedek Ã¼zerinde tablo tekrardan restore edilme adÄ±mÄ± gerekecektir. 

ğŸ”¸An index build fails with the CONCURRENTLY option, the index is marked as "invalid"  

REINDEX TABLE CONCURRENTLY komutu Ã§alÄ±ÅŸÄ±rken tamamlanmadan iptal edilirse (Ã¶rneÄŸin CTRL+C, pg_terminate_backend, sunucu restart gibi durumlarla), yeniden oluÅŸturulmaya Ã§alÄ±ÅŸÄ±lan indeks "invalid" (geÃ§ersiz) bir durumda kalÄ±r.
*/
reindex table concurrently test  ; --kill Ã§ekildi. 

-- invalid indeksleri tespit eden komut
SELECT * FROM pg_class, pg_index 
WHERE pg_index.indisvalid = false 
AND pg_index.indexrelid = pg_class.oid;

reindex table concurrently test  ; -- tekrar komut Ã§alÄ±ÅŸtÄ±rÄ±lmak istendiÄŸinde

-- WARNING:  skipping reindex of invalid index "public.test_c1_idx_ccnew"

reindex table  test  ;  -- concurrently olmadan reindex iÅŸlemin yÃ¼rÃ¼tÃ¼lmesi gerecektir. AccessExclusiveLock alacaktÄ±r tablo. okuma / yazma sen bir dur bakalÄ±m.

Reindex,
fragmantasyon, 
corruption,
concurrently yarÄ±da kesilmesi,

/*-------------------------------------------------------------
ğŸŒ https://www.postgresql.org/docs/17/sql-cluster.html
â­•ï¸ CLUSTER TABLE , Reorder data 
-- CLUSTER â€” cluster a table according to an index
---------------------------------------------------------------

â˜¢ï¸ CLUSTER tablo ACCESS EXCLUSIVE alÄ±r. block read/write

-- 
cluster test_table; --ilk defa cluster komutu yÃ¼rÃ¼ttÃ¼ÄŸÃ¼mÃ¼z durumda

ERROR:  there is no previously clustered index for table "test" 
SQL state: 42704


cluster  test_tablo using test_index_c1_idx; 

When a table is clustered, it is ğŸ’¥ physically reordered based on the index information. 
Clustering is a one-time operation: when the table is subsequently updated, the changes are not clustered.

That is, no attempt is made to store new or updated rows according to their index order.

Bir tabloda CLUSTER komutu yÃ¼rÃ¼tÃ¼ldÃ¼ÄŸÃ¼nde, fiziksel olarak seÃ§ilen indeksin sÄ±rasÄ±na gÃ¶re yeniden sÄ±ralanÄ±r (rewrite) . Ancak bu iÅŸlem tek seferliktir; tabloya sonradan yapÄ±lan ekleme veya gÃ¼ncellemelerde, veriler indeks sÄ±rasÄ±na gÃ¶re yerleÅŸtirilmez, yani ğŸ’¥sÄ±ralama dÃ¼zeni korunmaz.

*/

create table if not exists test_index_cluster (c1 int);
create index on test_index_cluster (c1);

insert into  test_index_cluster
select *
from (
select generate_Series(1,100_000)
) t1 order by random()


select * from test_index_cluster limit 100 -- karÄ±ÅŸÄ±k durumda geldi veriler.


--âš ï¸ Postgres fiziksel olarak order ÅŸekilde yazÄ±lÄ±m gerÃ§ekleÅŸtirilmez. primary key olsa bile. Gelen veri boÅŸluk olan data_pages iÃ§ine konulur.


explain (analyze ,buffers)
select * from test_index_cluster where c1>99 AND c1 <200

Bitmap Heap Scan on test_index_cluster  (cost=14.08..489.19 rows=565 width=4) (actual time=0.053..0.399 rows=100 loops=1)
  Recheck Cond: ((c1 > 99) AND (c1 < 200))
  Heap Blocks: exact=85
  Buffers: shared hit=87
  ->  Bitmap Index Scan on test_index_cluster_c1_idx  (cost=0.00..13.94 rows=565 width=0) (actual time=0.027..0.027 rows=100 loops=1)
        Index Cond: ((c1 > 99) AND (c1 < 200))
        Buffers: shared hit=2
Planning:
  Buffers: shared hit=3
Planning Time: 0.237 ms
Execution Time: 0.443 ms

-- kolondaki verinin yapÄ±sÄ± ile fiziksel yerleÅŸmesi arasÄ±ndaki farkÄ± anlamak iÃ§in istatiksik tablosundan yararlanabiliriz.


--https://www.postgresql.org/docs/current/view-pg-stats.html
/**
Statistical correlation between physical row ordering and logical ordering of the column values.
This ranges from -1 to +1. When the value is near -1 or +1, 
an index scan on the column will be estimated to be cheaper than when it is near zero,
due to reduction of random access to the disk.
**/

select   correlation from pg_Stats  where tablename ='test_index_cluster' limit 10 

-- â“â“â“ pg_stats gÃ¼ncelleyen bakÄ±m iÅŸlemi neydi â“â“â“ analyze 

analyze test_index_cluster -- Ã§alÄ±ÅŸtÄ±yorum pg_stats gÃ¼ncellenmesi iÃ§in

select   correlation from pg_Stats  where tablename ='test_index_cluster' limit 10 


explain (analyze ,buffers)
select * from test_index_cluster where c1>99 AND c1 <200;

Bitmap Heap Scan on test_index_cluster  (cost=5.30..243.09 rows=98 width=4) (actual time=0.058..0.442 rows=100 loops=1)
  Recheck Cond: ((c1 > 99) AND (c1 < 200))
  Heap Blocks: exact=90 ğŸ’¥  I/O iÅŸlemi , taranan data_pages
  Buffers: shared hit=92
  ->  Bitmap Index Scan on test_index_cluster_c1_idx  (cost=0.00..5.27 rows=98 width=0) (actual time=0.025..0.028 rows=100 loops=1)
        Index Cond: ((c1 > 99) AND (c1 < 200))
        Buffers: shared hit=2
Planning:
  Buffers: shared hit=6
Planning Time: 0.178 ms
Execution Time: 0.658 ms

-- Query complete 00:00:13.641

-- cluster komutu yÃ¼rÃ¼tÃ¼yorum
cluster test_index_cluster using  test_index_cluster_c1_idx ;


select   correlation from pg_Stats  where tablename ='test_index_cluster' limit 10
--0.0025889443 korelasyon deÄŸeri deÄŸiÅŸmedi

explain (analyze ,buffers)
select * from test_index_cluster where c1>99 AND c1 <200;

Bitmap Heap Scan on test_index_cluster  (cost=5.30..243.09 rows=98 width=4) (actual time=0.023..0.182 rows=100 loops=1)
  Recheck Cond: ((c1 > 99) AND (c1 < 200))
  Heap Blocks: exact=1ğŸ’¥
  Buffers: shared hit=3
  ->  Bitmap Index Scan on test_index_cluster_c1_idx  (cost=0.00..5.27 rows=98 width=0) (actual time=0.013..0.014 rows=100 loops=1)
        Index Cond: ((c1 > 99) AND (c1 < 200))
        Buffers: shared hit=2
Planning:
  Buffers: shared hit=16 --> shared_buffer iÃ§inde bulunmuÅŸ demek veri
   read=3 --> shared_buffer dÄ±ÅŸÄ±nda veri bulunmuÅŸtur, diskten Ã§aÄŸrÄ±lmÄ±ÅŸtÄ±r.
Planning Time: 0.261 ms
Execution Time: 0.370 ms

analyze test_index_cluster -- Ã§alÄ±ÅŸtÄ±yorum pg_stats gÃ¼ncellenmesi iÃ§in

select   correlation from pg_Stats  where tablename ='test_index_cluster' limit 10 
correlation 1 oldu.
14:00 

/*----------------------------------------------------------------
ğŸŒ https://www.postgresql.org/docs/current/monitoring.html
â­•ï¸ Chapter 28. Monitoring Database Activity
-- VeritabanÄ±nÄ± izleme 
 
------------------------------------------------------------------
Bir veritabanÄ± yÃ¶neticisi olarak ÅŸuan sistem ne yapÄ±yor ? 
VeritabanÄ±nÄ± daha iyi yÃ¶netilmesi saÄŸlayacak bilgilere eriÅŸim ? 


ğŸŒ https://www.postgresql.org/docs/current/monitoring-stats.html
ğŸ”¶ 28.2. The Cumulative Statistics System 

Cumulative statistics are collected in shared memory.

"kÃ¼mÃ¼latif Ä°statistik" ler shared_bufferda tutuluyor. 
Bir process toplanan Ä°statistik 

her Process yaptÄ±klarÄ± iÅŸlemlerin istatistik bilgileri kendileri toplar  
Ve  shared_buffer bulunan istatistik bilgilerin olduÄŸu tablolar ara ara gÃ¼nceller.

GÃ¼venli ÅŸekilde kapandÄ±ÄŸÄ±nda postgres bu ramdeki istatistik verisi , pg_stat klasÃ¶rÃ¼ altÄ±nda kaydeder.
BÃ¶ylece bir postgres server geri baÅŸladÄ±ÄŸÄ±nda, bu verilerde geri rame yÃ¼klenir. Yani istatistik bilgileri "resetlenmez".

GÃ¼vensiz kapanma durumunda yada crash durumunda istatisk verileri ise diske yazÄ±lma durumu gerÃ§ekleÅŸemeceÄŸi iÃ§in "resetlenir".


ğŸŒ https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-STATS-VIEWS

Table 28.1. Dynamic Statistics Views  (AnlÄ±k durum bilgileri verir.)
Table 28.2. Collected Statistics Views  (kÃ¼mÃ¼latif istatiksel bilgileri )



ğŸ”¶ Table 28.1. Dynamic Statistics Views 

â­•ï¸ pg_Stat_Activity
ğŸŒ https://www.postgresql.org/docs/16/monitoring-stats.html#MONITORING-PG-STAT-ACTIVITY-VIEW


/**
The pg_stat_activity view will have one row per server process, 
showing information related to the current activity of that process.
**/

Her sunucu iÅŸlemi (process) iÃ§in bir satÄ±r olacak ÅŸekilde, o iÅŸlemin mevcut durumu ve o anda Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ± sorgu gibi bilgileri gÃ¶sterir.

select * from pg_stat_activity limit 10

*/
-- her bir veritabanÄ±nda Ã§alÄ±ÅŸan baÄŸlantÄ± sayÄ±sÄ±
select count(*),datname from pg_Stat_activity group by datname

-- kullanÄ±cÄ± kÄ±rÄ±lÄ±mÄ±nda gelen  baÄŸlantÄ± sayÄ±sÄ±
select count(*),usename from pg_Stat_activity group by usename

-- uzun sÃ¼re Ã§alÄ±ÅŸan sorgular
select * from pg_Stat_activity; 

en son sorgu ne zaman yolladÄ±ÄŸÄ±nÄ± gÃ¶rmek iÃ§in -- query_start
sorgunun hala Ã§alÄ±ÅŸÄ±r durumda olduÄŸu anlamak iÃ§in -- state kolonu = active

select now() -query_start  ,* 
from   pg_stat_Activity   order by now() -query_start  desc nulls last 


select now() - query_start as "en_son_sorgu_yollandÄ±ÄŸÄ±_zaman" ,state, * 
from pg_stat_Activity 
where backend_type='client backend'
and state='active'
order by now() -query_start  desc nulls last ;

-- 3253 uzun Ã§alÄ±ÅŸan sorgum iptal etmek istiyorum.

select pg_cancel_backend (3253);  -->
-- process Ã¼zerinde Ã§alÄ±ÅŸan sorguyu sonlandÄ±rmak iÃ§inclient tarafÄ±na aÅŸaÄŸÄ±daki hata gÃ¶zlemlenir. BaÄŸlantÄ±sÄ± process sonlanmaz.

ERROR:  canceling statement due to user request 
SQL state: 57014

select pg_terminate_backend(3253); -- process sonlandÄ±rmak iÃ§in

FATAL:  terminating connection due to administrator command
server closed the connection unexpectedly
	This probably means the server terminated abnormally
	before or while processing the request.
The connection to the server was lost. Attempting reset: Succeeded.


select * from pg_stat_progress_basebackup --> Ã§alÄ±ÅŸan basebackup yedeÄŸin durumunu gÃ¶rmek iÃ§in
select * from pg_stat_progress_copy --> Ã§alÄ±ÅŸan copylarÄ± komutlarÄ±n durumunu gÃ¶rmek iÃ§in

copy (select * from asdsadad)  to ''  ,csv ,txt, custom delimeter
copy  ..  from ''  
copy (select now(), * from pg_stat_progress_basebackup) to '/pgdata/stat.txt' ;

/*--------------------------------------------
ğŸŒ https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-BGWRITER-VIEW
â­•ï¸ pg_stat_bgwriter
 containing data about the background writer of the cluster.
--------------------------------------------

select * from pg_stat_bgwriter 

-- shared_buffers iÃ§ersindeki dirty bufferlarÄ±mÄ±z diske yazÄ±mÄ±nÄ± gerÃ§ekleÅŸtiriyordu.

maxwritten_clean sayÄ±sÄ± yÃ¼ksekliyor ise, 
bgwriter temizleyeceÄŸinden daha fazla "dirty buffer" oluÅŸuyor demektedir. 
Yani bgwriter temizle iÅŸinde yavaÅŸ kalÄ±yor olabilir.
Normal kullanÄ±cÄ± sorgularÄ±nda perfomans kaybÄ± gÃ¶zlemlenebilir.
ğŸ¯  bgwriter_lru_maxpages yÃ¼kseltilmesi dÃ¼ÅŸÃ¼nÃ¼ebilir. yada daha sÄ±k bgwriter tetiklenmesi.
select * from pg_Settings where name like '%bgwriter%'
bgwriter_delay,bgwriter_lru_maxpages,bgwriter_lru_multiplier, parametreler Ã¼zerinde. 
Daha Ã§ok dirty buffer temizleyecek ÅŸekilde ayar yapÄ±lmalÄ±dÄ±r.

select pg_size_pretty(buffers_clean*8096), * from pg_stat_bgwriter 

/*--------------------------------------------
ğŸŒ https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-CHECKPOINTER-VIEW
â­•ï¸ pg_stat_checkpointer 
containing data about the checkpointer process
--------------------------------------------


select * from pg_stat_checkpointer;

checkpoint;

num_timed, checkpoint_timeout tetiklenme sayÄ±sÄ±
num_requested, max_wal_size, create database ,checkpoint vb ...
restartpoints, In archive recovery or standby mode, the server periodically performs restartpoints, which are similar to checkpoints in normal operation.

ğŸ¯ num_timed > num_requested  ÅŸeklinde olmasÄ± beklenir. 

num_timed az ise checkpoint , max_wal_size  tarafÄ±ndan tetikleniyordur. Bu parametrenin yÃ¼kseltilmesi Ã¶nerilir.

v17 Ã¶ncesi pg_bgwriter iÃ§eririsinden takip edilebilir. checkpoints_timed>checkpoints_req

/*--------------------------------------------
ğŸŒ https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-IO-VIEW
â­•ï¸ PG-STAT-IO
--------------------------------------------
pg16 ile birlikte geldi. database cLusterÄ±mÄ±zdaki I/O durumu hakkÄ±nda kÃ¼mÃ¼latif bilgi vermekte.
select *  from pg_stat_io ; --Ã¼zerindeki kolonlarÄ± ve gÃ¶zlemeyeceÄŸimiz deÄŸerlere bakalÄ±m.

ğŸ”¶ backend_type -> istatiksel bilgisi toplanan backend prrocess
select distinct backend_type from pg_Stat_io;
background worker
client backend
walsender
standalone backend
autovacuum worker
autovacuum launcher
background writer
startup
checkpointer

select *  from pg_stat_io where backend_type in ('client backend','background writer','checkpointer')


ğŸ”¶ context -> yapÄ±lan I/O operasyonu ne olduÄŸu gÃ¶sterir
	--normal: 
	The default or standard context for a type of I/O operation. 
	For example, by default, relation data is read into and written out from shared buffers. 
	Thus, reads and writes of relation data to and from shared buffers are tracked in context normal.
KullanÄ±cÄ± sorgularÄ±nda bu istatistik bilgeri gÃ¼ncellenir.
	- vacuum: autovacuum ve vacuum sÃ¼reÃ§lerinde gÃ¶zÃ¼kÃ¼r.
	  I/O operations performed outside of shared buffers while vacuuming and analyzing permanent relations. 
		Temporary table vacuums use the same local buffer pool as other temporary table IO operations 
		and are tracked in context normal.
	-- bulkread:
	   Certain large read I/O operations done outside of shared buffers, 
		 for example, a sequential scan of a large table.
	-- bulkwrite:
	   Certain large write I/O operations done outside of shared buffers, such as COPY
**/*/*/
SELECT backend_type, object, context, 
-- her bir kolon blok iÅŸlemini tipini 
-- deÄŸerler ise kaÃ§ kez bu blok iÅŸleminin gerÃ§ekleÅŸtiÄŸine karÅŸÄ±lÄ±k sayÄ±lardÄ±r.
hits,writes, --shared_buffer okuma, yazma          (shared_buffer)
reads,writebacks,  -- diskten okuma, diske yazma   (disk)
extends,-- yeni sayfa ihtiyacÄ± (diskten yeni blok)  (disk) 
evictions, -- shared buffer boÅŸaltma talep (baÅŸka veri iÃ§in yer aÃ§ma) data_buffer(clean) <-> data_pages
reuses, -- ring buffer kullanÄ±mÄ± (bulkread,bulkwrite or vacuuum )  (ram)
fsyncs,  -- fsync iÅŸlem talep sayÄ±sÄ± (kalÄ±cÄ± diske yazÄ±m)  (disk)
stats_reset
FROM pg_catalog.pg_stat_io 
order by reuses desc nulls last  ; 

-- â“â“ Querylerimizin aradÄ±ÄŸÄ± verilerin nerede olmasÄ±nÄ± bekleriz â“â“ 



-- tablo Ã¼zerinde deÄŸerleri yorumlayalÄ±m. 
-- uzun sÃ¼re toplanan bir istatik verisini olduÄŸu ortamda
select backend_type,context,sum(hits),
pg_size_pretty(sum(hits*8096)) as hits,pg_size_pretty(sum(writes*op_bytes)) as writes,
pg_size_pretty(sum(reads*op_bytes)) as reads ,pg_size_pretty(sum(writebacks*op_bytes)) as writebacks,
pg_size_pretty(sum(evictions*op_bytes)) as evictions 
from pg_stat_io where backend_type ='client backend'
group by backend_type,context

/*
client backend,context (normal)  satÄ±rÄ±ndaki, hits deÄŸerinin > reads bÃ¼yÃ¼k olmasÄ± sorgularÄ±mÄ±zÄ±n aradÄ±ÄŸÄ± verileri shared_buffer iÃ§inde yani cacheden okuduÄŸuna iÅŸaret eder.

ğŸ¯ evictions sayÄ±sÄ±nÄ±n fazla olmasÄ±nÄ±, shared_buffera dÃ¼ÅŸÃ¼k olduÄŸuna iÅŸaret edecektir.
*/

select backend_type,context,writebacks,fsyncs from pg_stat_io 
where backend_type in ('client backend','background writer','checkpointer',
'background worker','autovacuum worker')
and fsyncs >0  , 

fsynclerin , background writer, checkpointer tarafÄ±ndan gerÃ§ekleÅŸtirilmeli.

				        writebacks    | fsyncs
checkpointer	normal	222271	           171
client backend	normal  2222712           1000
/*
ğŸ¯ fsync sayÄ±larÄ± karÅŸÄ±laÅŸtÄ±rma yaptÄ±ÄŸÄ±nÄ±zda client backend, normal karÅŸÄ±lÄ±k satÄ±r deÄŸerleri checkpointer ve bgwriter gÃ¶re fazla ise, dirty buffer temizliÄŸi Ã§alÄ±ÅŸan sorgularÄ±mÄ±z tarafÄ±nda yapÄ±lÄ±yor demektir. sorgu perfomansÄ±mÄ±z dÃ¼ÅŸÃ¼ecektir. 
*/


/*--------------------------------------------
ğŸŒ https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-DATABASE-VIEW
â­•ï¸ pg_stat_database
--------------------------------------------
create database profelis;
select * from pg_stat_database ;

SELECT datid, datname, numbackends, --aktif connection sayÄ±sÄ±
-- ğŸ¯ connection havuzunu database limitlerken kontrol iÃ§in
xact_commit, xact_rollback, 

blks_read, -- veriye diskten eriÅŸilmesi
blks_hit,  -- veriye shared_buffer eriÅŸilmesi   

-- ğŸ¯ blks_hit/blks_read oranÄ±n yÃ¼ksek olmasÄ± cache aÄŸÄ±rlÄ±k Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± gÃ¶sterir.
tup_returned, -- seq_scan ve index Ã¼zerinen bulunan satÄ±r sayÄ±sÄ±
tup_fetched,  -- index ile bulunan satÄ±r sayÄ±sÄ±

-- ğŸ¯ tup_fetched/tup_returned oranÄ±n yÃ¼ksek olmasÄ± index yÃ¶nelimin yÃ¼ksek olduÄŸunu gÃ¶sterir.
-- tup_fetched =0 ise index kullanÄ±mÄ± gerÃ§ekleÅŸmiyÄ±r.
tup_inserted, -- insert olan satÄ±r sayÄ±sÄ±
tup_updated,  -- update iÅŸlemi gÃ¶re satÄ±r sayÄ±sÄ±
tup_deleted,  -- silme iÅŸlemi gerÃ§ekleÅŸen satÄ±r sayÄ±sÄ±

conflicts, -- Number of queries canceled due to conflicts with recovery in this database. (Conflicts occur only on ğŸ’¥ standby servers)

temp_files, temp_bytes, 
-- Number of temporary files created by queries in this database. All temporary files are counted, regardless of why the temporary file was created (e.g., ğŸ’¥ sorting or hashing) 

-- bu veritabanÄ±n Ã§alÄ±ÅŸan sorgular kontrol edilerek temp_file oluÅŸumu engellenmeli yada work_mem tune yapÄ±lmasÄ± dÃ¼ÅŸÃ¼nÃ¼lmeli.

deadlocks,
-- Ã§ok fazla deadlock oluyor ise bu veritabanÄ± Ã¼zerinde Ã§alÄ±ÅŸan sorgular / uygulama incelenmeli

checksum_failures, checksum_last_failure, 
-- data_checkums initdb esnasÄ±nda -k ile aktif oluyor.
-- â˜¢ï¸ >0 bÃ¼yÃ¼k ise disk yada disk bileÅŸenleri kontrol edilmeli. veri kaybÄ± gerÃ§ekleÅŸiyordur.

session_time, -- toplam sÃ¼ren baÄŸlantÄ± sÃ¼resi
active_time, 
idle_in_transaction_time, 
sessions, -- toplam sesions
sessions_abandoned, -- client baÄŸlantÄ±sÄ±nÄ±n kesilmesi yÃ¼zÃ¼nden dÃ¼ÅŸen sesionlar.
sessions_fatal, -- fatal error tarafÄ±ndan Ã¶ldÃ¼rÃ¼len baÄŸlantÄ± sayÄ±sÄ±
-- âš ï¸ fatal sayÄ±sÄ± artÄ±yor ise gÃ¼nden gÃ¼ne ilgili veritabanÄ± gelen ve fatal Ã¼reten sorgu incelenmeli
sessions_killed, -- kill komutu ile Ã¶ldÃ¼rÃ¼len baÄŸlantÄ± sayÄ±sÄ±
stats_reset
FROM pg_catalog.pg_stat_database;

--ğŸ¯ tup_fetched index okumasÄ± az gerÃ§ekleÅŸiyor ise bu veritabanÄ± Ã¼zerinden Ã§alÄ±ÅŸan sorgular pg_stat_statements Ã¼zerinden incelenmeli ve dokunduÄŸu tablolar (pg_stat_user_Tables, pg_stat_user_indexes ) index iyileÅŸtirmesi dÃ¼ÅŸÃ¼nÃ¼lebilir.



/*--------------------------------------------
ğŸŒ https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-ALL-TABLES-VIEW
â­•ï¸ pg_stat_all_Tables,pg_stat_user_tables,pg_stat_sys_tables
-- tabloya eriÅŸim ile ilgili istatiksel bilgiler bulunur.
--------------------------------------------
-- baÄŸlÄ± olduÄŸum db tablolara ati bir takÄ±m istatitksel bilgiler
select * from pg_Stat_user_tables;


SELECT relid, --obje id 
schemaname,  relname, --ÅŸema ve tablo ismi
seq_scan, last_seq_scan, seq_tup_read, --seq_scan adeti, en son gerÃ§ekleÅŸme , kaÃ§ satÄ±r okundu.
idx_scan, last_idx_scan, idx_tup_fetch, --index scan adeti, en son gerÃ§ekleÅŸme , kaÃ§ satÄ±r okundu.

-- ğŸ¯ idx_scan < seq_scan  olan tablolarda index oluÅŸturmak dÃ¼ÅŸÃ¼nebilir. 

create extension pg_stat_statements;
select * from pg_stat_statements limit 5, query kolonun eriÅŸilen tespit edileiblir.
select * from pg_stat_statements where query like '%tablo_ismi%';

n_tup_ins, n_tup_upd, n_tup_del, n_tup_hot_upd, n_tup_newpage_upd, -- DML iÅŸleminden etkilen satÄ±rlarÄ±n adetleri

n_live_tup, -- Estimated number of live rows
--ğŸ¯ tÃ¼m tablonun satÄ±r sayÄ±sÄ± almak iÃ§in kullanÄ±labilir. vacuum iÅŸlemi ne kadar gÃ¼ncel ise o kadar doÄŸru sonuÃ§ verecekti
select count(*) from table_name -> iÅŸlemi vakit sÃ¼reÃ§

n_dead_tup, -- son vacuum iÅŸleminden beri oluÅŸan dead_tup sayÄ±sÄ±

n_mod_since_analyze,  --Estimated number of rows modified since this table was last analyzed
n_ins_since_vacuum,  -- Estimated number of rows inserted since this table was last vacuumed

select n_live_tup*0.02, * from pg_stat_user_Tables order by n_live_tup desc --> scale factor ayarÄ± gerektire ntablolarÄ±n tespiti


last_vacuum,  --Last time at which this table was manually vacuumed (not counting ğŸ’¥ VACUUM FULL)
last_analyze,  --last_analyze timestamp with time zone
-- manuel bakim iÅŸlemlerin takibi iÃ§in
last_autovacuum, --Last time at which this table was vacuumed by the autovacuum daemon
last_autoanalyze,  --last_autoanalyze timestamp with time zone
-- ğŸ¯ autovacuum saÄŸlÄ±klÄ± ÅŸekilde tÃ¼m tablolarÄ± taradÄ±ÄŸÄ±nÄ± gÃ¶rmek iÃ§in dikkat edilmeli

FROM pg_catalog.pg_stat_all_tables;
*/*/
-- hiÃ§ vacuum gÃ¶rmemiÅŸ tablolarÄ± getirebiliriz.
select * from pg_stat_user_tables where vacuum_count is null or   autovacuum_count is null

-- â˜¢ï¸ bir tablo sorgu yavaÅŸlÄ±ÄŸÄ± var ise, tablonun enson
last_autoanalyze,last_autovacuum,last_analyze,last_vacuum  gÃ¶rdÃ¼ÄŸÃ¼ kontrol edilebilir. yakÄ±n zamanda bir bakÄ±m iÅŸlemi yok ise 

-- manuel analyze vacuum sonrasÄ± sorgu perfomansÄ± artÄ±ÅŸÄ± oluyor ise , autovacuum parametresi iyileÅŸtirme dÃ¼ÅŸÃ¼nebilir.

-- ğŸ¯ GÃ¼ndÃ¼zleri yoÄŸun Ã§alÄ±ÅŸan bir veritabanÄ±nda, autovacuum sÃ¼reci her tabloya yetiÅŸemediÄŸi durumda, geceleri yada haftalÄ±k dÃ¶nÄŸÃ¼de vacuumdb komutu ile paralel ÅŸekilde tablolarÄ± hÄ±zlÄ±ca tarayacak Ã§alÄ±ÅŸtÄ±rma ayarÄ± yapÄ±labilir.

vacuumdb -j 10  vm tablo her 



/*--------------------------------------------
ğŸŒ https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-ALL-INDEXES-VIEW
â­•ï¸ pg_stat_all_indexes,pg_stat_user_indexes,pg_stat_sys_indexes
-- indexlere ait istatiksel bilgiler bulunur.
--------------------------------------------


select * from pg_stat_user_indexes ;

SELECT  relid, indexrelid, 
		schemaname, relname,  -- indexin olduÄŸu ÅŸema.tablo bilgisi
		indexrelname, -- index ismi
		idx_scan, -- kaÃ§ kez indexin kullanÄ±ldÄ±ÄŸÄ±
		--ğŸ¯ idx_scan =0 ise bu index kullanÄ±lmadÄ±ÄŸÄ± belirtir.
-- bu indexlerin neden kullanÄ±lmadÄ±ÄŸÄ± incelenerek DROP INDEX yada iyileÅŸtirme dÃ¼ÅŸÃ¼nÃ¼lmeli.
last_idx_scan, 
		idx_tup_read, -- index scani sonucu yakalnan satÄ±r
		idx_tup_fetch -- index scani sonucu tablo Ã¼zerinden eriÅŸlen satÄ±r sayÄ±sÄ±
	-- index-only-scan, dead-tuple vb.. durumlardan tup_read > tup_fetch
		-- arasÄ±nda fark oluÅŸmasÄ± normal.
FROM pg_catalog.pg_stat_all_indexes order by idx_Scan desc ;


/*--------------------------------------------
ğŸŒ https://www.postgresql.org/docs/16/monitoring-stats.html#MONITORING-PG-STATIO-ALL-TABLES-VIEW
â­•ï¸ pg_statio_all_tables,pg_statio_user_tables,pg_statio_sys_tables
-- tablolara ait I/O istatistikleri
--------------------------------------------


select * from pg_catalog.pg_statio_user_tables ;

/*
ğŸ¯  heap_blks_read deÄŸeri 0 ise tablomuz atÄ±l durumda kullanÄ±lmÄ±yor olarak dÃ¼ÅŸÃ¼nebilir. Kurum iÃ§i deÄŸerlendirme sonrasÄ± bu tÃ¼r tablolarÄ±n kaldÄ±rÄ±lmasÄ± veya arÅŸivlenmesi dÃ¼ÅŸÃ¼nÃ¼lebilir.

ğŸ¯ heap_blks_hit / heap_blks_read OranÄ±, tablomuz shared_buffer (cache) bulunma durumu hakkÄ±nda yorum yabiliriz.

select schemaname, relname,heap_blks_hit/nullif(heap_blks_read,0) from pg_catalog.pg_statio_user_tables  order by 3  desc nulls last  

>1 ,  Veri bÃ¼yÃ¼k oranda bellekten okunuyor. Ä°yi cache performansÄ±
<0 , Verinin Ã§oÄŸu diskten okunuyor Bellek yetersiz olabilir.

ğŸ¯ SÄ±k eriÅŸilen verilerin olduÄŸu (SÄ±cak veri ) tablolarda bu oranÄ±n yÃ¼ksek olmasÄ±nÄ± bekleriz. kullanÄ±cÄ± tablosu, Ã¼rÃ¼n bilgileri gibi tablolarÄ± filtreleyip bu tablolarÄ±n *_hit oranlarÄ±n yÃ¼ksek olmasÄ±nÄ± saÄŸlanmasÄ±. Disk I/O yerine in-memory (cache) eriÅŸim gerÃ§ekleÅŸtiÄŸi gÃ¶sterir, bu da sorgu performansÄ±nÄ± ciddi oranda artÄ±rÄ±r.

/*--------------------------------------------
ğŸŒ https://www.postgresql.org/docs/16/monitoring-stats.html#MONITORING-PG-STATIO-ALL-INDEXES-VIEW
â­•ï¸ pg_statio_all_indexes,pg_statio_user_indexes,pg_statio_sys_indexes
-- indexlere ait I/O istatistikleri
--------------------------------------------

select * from pg_statio_user_indexes


SELECT relid, indexrelid, schemaname, relname, 
indexrelname, 
idx_blks_read, idx_blks_hit
-- ğŸ¯ idx_blks_hit / idx_blks_read OranÄ±, tablomuz shared_buffer (cache) bulunma durumu hakkÄ±nda yorum yabiliriz. yÃ¼ksek olmasÄ± in-memory (cache) aÄŸÄ±rlÄ±klÄ± olmasÄ± veritabanÄ± perfomansÄ± artÄ±racaktÄ±r.
FROM pg_catalog.pg_statio_all_indexes;


pg_stat_activity
pg_stat_bgwriter
pg_stat_checkpointer
pg_stat_io
pg_stat_database
pg_stat_all_tables
pg_stat_all_indexes
pg_statio_all_tables
pg_statio_all_indexes

/*--------------------------------------------
ğŸŒ https://www.postgresql.org/docs/16/monitoring-stats.html#MONITORING-STATS-FUNCTIONS
-- istatik verileri yÃ¶netimde kullanÄ±lan fonksiyonlar
--------------------------------------------
*/

-- Resets all statistics counters for the current database to zero.
select pg_stat_reset () â†’ void
-- â˜¢ï¸  reset iÅŸlemi kullanÄ±mÄ± Ã§ok sÄ±k yapÄ±lmalÄ±, autovacuum sÃ¼reÃ§leri Ã§alÄ±ÅŸmasÄ±nÄ± etkileyecektir.

select * from pg_stat_user_tables 

select * from pg_stat_user_tables ;

-- "archiver", "bgwriter", "checkpointer", "io", "recovery_prefetch", "slru", or "wal".
pg_stat_reset_shared ( text ) â†’ void

select * from pg_Stat_reset_shared('checkpointer');

select * from pg_Stat_checkpointer;


PARTÄ°TON

/*
-----------------------------------------------------------------
-- https://www.postgresql.org/docs/current/ddl-partitioning.html#DDL-PARTITIONING-OVERVIEW
-- ğŸŒ Table Partitioning 

â„¹ï¸ Table Partition, bir tabloyu daha kÃ¼Ã§Ã¼k fiziksel tablolara bÃ¶lme iÅŸlemidir. KullanÄ±cÄ± iÃ§in mantÄ±ksal olarak tek bir tablo gibi gÃ¶rÃ¼nÃ¼r, fakat arka planda birÃ§ok alt tabloya (partition) daÄŸÄ±tÄ±lÄ±r.

ğŸ”¸ EÄŸer sorgularda WHERE koÅŸulu partition kuralÄ± ile Ã¶rtÃ¼ÅŸÃ¼yorsa, PostgreSQL sadece ilgili partitionâ€™a eriÅŸir, bu da sorgu performansÄ±nÄ± artÄ±rÄ±r. 

ğŸ”¸ Ä°ndeks boyutlarÄ±nda kÃ¼Ã§Ã¼lme, Ã§Ã¼nkÃ¼ veri fiziksel olarak bÃ¶lÃ¼nmÃ¼ÅŸ olduÄŸundan daha az Ã§atallaÅŸma olur. Bu da shared_buffers kullanÄ±mÄ±nÄ± azaltabilir. 

ğŸ”¸ BakÄ±m iÅŸlemleri, Ã¶rneÄŸin eski veriyi silebilmek, daha kolaydÄ±r (tek bir partition DROP ile). 
--  Postgresde 3 farklÄ± partition yÃ¶ntemi belirleyebiliyoruz.
ğŸ”¸Range Partitioning  5 ile 10 arasÄ±,  10> dan bÃ¼yÃ¼k 
ğŸ”¸List Partitioning  ( Elma , Armut ) , doÄŸu batÄ± kuzey gibi ayrÄ±mlardan, verinin sahip olduÄŸu etiketler
ğŸ”¸Hash Partitioning  eÅŸit bÃ¼yÃ¼klÃ¼klere ayÄ±rmada. (sorgu perfomansÄ± kazanÄ±mÄ± yok, bakÄ±m iÅŸleri kolay yapÄ±lÄ±yor.)

























































































































































































	



































































