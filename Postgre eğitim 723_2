-- eÄŸitim 2.gÃ¼n
1.Binary kurulumu (postgresql.org/downloads)

sudo apt install curl ca-certificates
sudo install -d /usr/share/postgresql-common/pgdg
sudo curl -o /usr/share/postgresql-common/pgdg/apt.postgresql.org.asc --fail https://www.postgresql.org/media/keys/ACCC4CF8.asc
. /etc/os-release
sudo sh -c "echo 'deb [signed-by=/usr/share/postgresql-common/pgdg/apt.postgresql.org.asc] https://apt.postgresql.org/pub/repos/apt $VERSION_CODENAME-pgdg main' > /etc/apt/sources.list.d/pgdg.list"
sudo apt update
sudo apt -y install postgresql

systemctl stop postgresql@17-main.service 
systemctl disable  postgresql@17-main.service 
systemctl disable  postgresql.service
systemctl stop   postgresql.service

2.Database cluster, dizini kurulumu (initdb)
3.Database Server BaÅŸlatma (pg_ctl)

find / -iname pg_ctl

/usr/lib/postgresql/17/bin/initdb -D /data/pg17 -k  --checksum 


listen_addresses='*'
#port
shared_buffers
work_mem
shared_buffers + max_connections*work_mem + max_connections*temp_buffers  < total_ram 
bgwriter_delay = 20ms               
bgwriter_lru_maxpages = 400

effective_io_concurrency = 200 

--cpu 32
max_worker_processes = 32              # (change requires restart)
max_parallel_workers_per_gather = 8    # limited by max_parallel_wor>
max_parallel_maintenance_workers = 8   # limited by max_parallel_wor>
max_parallel_workers = 32 

max_wal_size = 10GB
min_wal_size = 1GB
random_page_cost = 1.2 - 1.4

effective_cache_size = ram- shared_buffer

logging_collector = on
log_filename = 'postgresql-%Y-%m-%d.log'
log_line_prefix = '%h %u %m [%p]'
log_statement='ddl'
datestyle = 'iso, dmy'
timezone=''

/usr/lib/postgresql/17/bin/pg_ctl start -D /data/pg17


/*
---------------------------------------------------------------------
ğŸ’¼ Ã‡alÄ±ÅŸma ikiden fazla data_dizin

-- 1ï¸âƒ£ Dizinlerin HazÄ±rlanmasÄ±
--Ã–ncelikle PostgreSQL verilerini saklayacaÄŸÄ±mÄ±z dizinleri oluÅŸturuyoruz.

--Root KullanÄ±cÄ±sÄ±nda:
mkdir /pgdata
chown postgres:postgres /pgdata

--PostgreSQL kullanÄ±cÄ±sÄ±na geÃ§iÅŸ yapÄ±yoruz:
su - postgres

--PostgreSQL KullanÄ±cÄ±sÄ±nda:
mkdir /pgdata/pg16
mkdir /pgdata/pg17
--Bu dizinler PostgreSQL'in farklÄ± sÃ¼rÃ¼mleri iÃ§in ayrÄ± clusterlar oluÅŸturmak amacÄ±yla kullanÄ±lacaktÄ±r.

-- 2ï¸âƒ£ PostgreSQL ClusterlarÄ±nÄ± OluÅŸturma

--PostgreSQL 16 ClusterÄ±nÄ± OluÅŸturma
/usr/lib/postgresql/16/bin/pg_ctl initdb -D /pgdata/pg16 -o "-k"

--PostgreSQL 17 ClusterÄ±nÄ± OluÅŸturma
/usr/lib/postgresql/17/bin/pg_ctl initdb -D /pgdata/pg17 -o "-k"

-- 3ï¸âƒ£ ClusterlarÄ± BaÅŸlatma

-- Kurulan PostgreSQL clusterlarÄ±nÄ± baÅŸlatÄ±yoruz:
/usr/lib/postgresql/16/bin/pg_ctl start -D /pgdata/pg16
/usr/lib/postgresql/17/bin/pg_ctl start -D /pgdata/pg17

-- ğŸ” Neden BÃ¶yle Bir YapÄ±ya Ä°htiyaÃ§ Duyabiliriz?

Major sÃ¼rÃ¼m gÃ¼ncellemeleri gerÃ§ekleÅŸtireceÄŸimiz durumlarda.

Test ortamlarÄ±nda, geliÅŸtirilen uygulamalar iÃ§in birbirinden izole PostgreSQL clusterlarÄ± oluÅŸturmak amacÄ±yla.

---
pg_upgrade  , 
link mode , yarÄ±da kalÄ±rsa geri dÃ¶nÃ¼ÅŸ olmuyor
pg16
pg17 dizini oluÅŸturuyor pg_upgade link en az kapanmaya saÄŸlanÄ±yor.


pg_17 start

pg_upgrade  , 
pg16 1tb
pg17 1tb boÅŸta yer alamam 1saat sÃ¼recekliyor.



logical_replication,

pg16 procduction Ã§alÄ±ÅŸÄ±yr
pg17 ,

pg16 -> pg17 logical replication  ,  


*/*/

/*
ğŸ’¼ Ã‡alÄ±ÅŸma servis dosyasÄ± yapÄ±landÄ±rma

Bu iki kÃ¼me iÃ§in restart sonrasÄ± otomatik baÅŸlamasÄ± iÃ§in gerekli ayarlamalÄ± yapÄ±lmasÄ±.
-- Daemon servisi dÃ¼zenlemesi
-- ğŸŒ https://www.postgresql.org/docs/16/server-start.html


/etc/systemd/system/postgresql-17.service


[Unit]
Description=PostgreSQL database server
Documentation=man:postgres(1)
After=network-online.target
Wants=network-online.target

[Service]
Type=notify
User=postgres
ExecStart=/usr/lib/postgresql/17/bin/postgres -D /data/simple_data
ExecReload=/bin/kill -HUP $MAINPID
KillMode=mixed
KillSignal=SIGINT
TimeoutSec=infinity

[Install]
WantedBy=multi-user.target


10:30 - 11:00 


psql -h 10.10.11.141 -p 5432 -U postgres -d postgres 

psql: error: connection to server at "10.10.11.141", port 5432 failed: Connection refused
	Is the server running on that host and accepting TCP/IP connections?


listen_address='*'  deÄŸiÅŸikliÄŸi yapÄ±ldÄ±.


profelis@profelis:~$ psql -h 10.10.11.141 -p 5432 -U postgres -d postgres 
psql: error: connection to server at "10.10.11.141", port 5432 failed: FATAL:  no pg_hba.conf entry for host "10.10.11.1", user "postgres", database "postgres", no encryption


data dizini iÃ§erisindeki pg_hba.conf , ip izni tanÄ±mÄ± yapÄ±ldÄ±.

host    all             all             10.10.11.1/32           scram-sha-256



/usr/lib/postgresql/17/bin/pg_ctl reload -D /data/simple_data/
2025-05-14 08:10:05.981 UTC [1427] LOG:  received SIGHUP, reloading configuration files
server signaled


postgres serverÄ±n aktif hba kurallarÄ±n Ä±gÃ¶rmek iÃ§in .

select * from pg_hba_file_rules ; --> bu sorgu ile check edilmeli.


profelis@profelis:~$ psql -h 10.10.11.141 -p 5432 -U postgres -d postgres 
Password for user postgres: 
psql: error: connection to server at "10.10.11.141", port 5432 failed: FATAL:  password authentication failed for user "postgres"


Åifre tanÄ±mÄ± gerÃ§eklememiÅŸ olabilir ? 

select * from pg_shadow; --> server Ã¼zerinde ÅŸifre tanÄ±mÄ± kontrolu yapÄ±lÄ±r.

alter role postgres with password 'postgres'; --> ÅŸifre tanÄ±mÄ± gerÃ§ekleÅŸtirilir.

*/

create role prod with password '1234' login superuser   ; 

/*
5.pg_hba Kimlik doÄŸrulama ve AÄŸ,Port dinleme

/*
Client Authentication (Kimlik DoÄŸrulama)
https://www.postgresql.org/docs/current/auth-pg-hba-conf.html

â­•ï¸ Postgres, Kimlik doÄŸrulama kurallarÄ± pg_hba.conf konfigurasyon dosyasÄ±nÄ±n iÃ§inde tutulmaktadÄ±r.
â­•ï¸ Kurallar yukarÄ±nda aÅŸaÄŸÄ±ya doÄŸru kontrol edilmektedir. ilk uyan kuralda tarama sonlanmaktadÄ±r.
â­•ï¸ pg_hba kÃ¼me baÅŸlarken yÃ¼klenir sonrasÄ±nda yapÄ±lan deÄŸiÅŸiklikler etkilenmesi iÃ§in reload komutu yeterli olur. â„¹ï¸ Production ortamlarÄ±nda restart gerektiren durum oluÅŸturmaz.

â„¹ï¸ sql_command, select * from pg_hba_file_rules;  ile serverda aktif kurallarÄ± gÃ¶rebiliriz. 


/*----------------------------------------
ğŸ”´  Concurrency Control (eÅŸzamanlÄ± eriÅŸimde kurallar)
ğŸŒ https://www.postgresql.org/docs/current/mvcc.html
----------------------------------------

ğŸ”¸ VeritabanÄ± sistemlerinde aynÄ± veriye birden fazla kullanÄ±cÄ±nÄ±n aynÄ± anda eriÅŸmesi ve iÅŸlemler yapmasÄ±, veri tutarlÄ±lÄ±ÄŸÄ± (data consistency) ve performans korumak iÃ§in eklenmiÅŸ yapÄ±lar bulunmakta.

1. Transaction Isolation  (MVCC)
2. Explicit Locking  (LOCK mekanizmasÄ±)

/*----------------------------------------
ğŸ”¶ Multi-Version Concurrency Control (MVCC)
ğŸŒ https://www.postgresql.org/docs/17/glossary.html#GLOSSARY-MVCC
----------------------------------------

A mechanism designed to allow several transactions to be reading and writing the same rows without one process causing other processes to stall. In PostgreSQL, MVCC is implemented by creating copies (versions) of tuples as they are modified; after transactions that can see the old versions terminate, those old versions need to be removed.

ğŸ”º MVCC ile, okuyanlar yazanlarÄ± / yazanlar ise okuyanlarÄ± engellemeden Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlar. 

ğŸ”º Multi-version ifade ile her iÅŸlem baÅŸladÄ±ÄŸÄ±nda o anlÄ±k  veritabanÄ±nÄ±n versiyonuna sahip olur 
(snapshot). satirlarda bulunan txid ile snapshot idi karÅŸÄ±laÅŸtÄ±rmasÄ± ile lock mekanizmasÄ±na kullanÄ±lmadan paralel iÅŸlemler daha perfomanslÄ± ÅŸekilde yÃ¼rÃ¼tÃ¼lÃ¼r. 

*/*/*/*/

create table test (c1 int);

insert into test (c1) values(1);

select xmin,*  from test ;
/*
ğŸ”º Veri deÄŸiÅŸikliklerinde yeni satÄ±rlar oluÅŸturulur veya eskisini geÃ§ersiz kÄ±lacak bir iÅŸaret alarak gerÃ§ekleÅŸir.

    delete iÅŸleminde, etkilenen satÄ±r fiziksel olarak silinmez sadece geÃ§ersiz kÄ±lÄ±nÄ±r.
	insert iÅŸleminde, yeni satÄ±r yazÄ±lma iÅŸlemi gerÃ§ekleÅŸir.
	update iÅŸleminde, delete + insert combine

ğŸ”º delete ve update iÅŸlemleri sonucu oluÅŸan hayelet satÄ±rlar bir sÃ¼re sonra paralelde Ã§alÄ±ÅŸan transactionlarÄ±n ihtiyaÃ§Ä± olmayacaÄŸÄ± iÃ§in boÅŸ yere tutulmuÅŸ olacaktÄ±r.

â“ OluÅŸan hayalet satÄ±rlar ne oluyorâ“

https://www.postgresql.org/docs/17/glossary.html#GLOSSARY-Bloat
ğŸ’¥BLOATğŸ’¥

ğŸ”º Space in data pages which does not contain current row versions, such as unused (free) space or outdated row versions.

   Data pagelerinde kullanÄ±lmayan (boÅŸ) alan veya eski satÄ±r versiyonlarÄ± gibi geÃ§erli olmayan satÄ±larÄ± iÃ§eren alan.

â˜¢ï¸ Database bloat durumun takip edilmesi gerekir, 
Gereksiz bloat alanÄ± sorgu perfomansÄ±n dÃ¼ÅŸmesine,fiziksel alanÄ± tÃ¼keterek Postgresâ€™in kapanmasÄ±na sebebiyet verecek durumlar oluÅŸturabilir. â˜¢ï¸

â“ Bu olumsuz durum nasÄ±l engelleniyor â“
Postgres de bu iÅŸlem vacuum/autovacuum sÃ¼reci ile optimize edilmektedir.

â“ MVCC kuralÄ±nda paralel Ã§alÄ±ÅŸan transaction gerÃ§ekleÅŸen dml (delete/insert/update) iÅŸlemlerinde nasÄ±l etkileniyor â“

Bir transaction bloÄŸunda select attÄ±ÄŸÄ±m veriyi biri paralelde update ettiÄŸinde , gÃ¼ncel halinimi gÃ¶receÄŸim / eski halini gÃ¶rmeye devam mÄ± edeceÄŸim ? bu benzeri durumlarÄ±,

DML iÅŸlemlerin etkilerini sÄ±nÄ±rlayan SQL STANDARTI olan, 4 adet transaction isolation bulunmakta. 

1ï¸âƒ£ Dirty Read (Kirli Okuma) (postgres mÃ¼mkÃ¼n deÄŸil)
ğŸ”¸ Bir iÅŸlem, henÃ¼z commit edilmemiÅŸ baÅŸka bir iÅŸlemin yazdÄ±ÄŸÄ± veriyi okur.
ğŸ”¸ EÄŸer diÄŸer iÅŸlem rollback ederse, ilk iÅŸlem geÃ§ersiz veriyi okumuÅŸ olur.

2ï¸âƒ£ Non-repeatable Read (Tekrarlanamayan Okuma) (postgres varsayÄ±lan )

ğŸ”¸ Bir iÅŸlem, daha Ã¶nce okuduÄŸu bir veriyi tekrar okuduÄŸunda, o veri baÅŸka bir iÅŸlem tarafÄ±ndan deÄŸiÅŸtirilmiÅŸ olabilir.
ğŸ”¸ SonuÃ§ olarak, aynÄ± iÅŸlem iÃ§inde veri farklÄ± deÄŸerlerle gÃ¶rÃ¼nebilir.

begin; baÅŸladÄ±ÄŸÄ±mÄ±z bir transaction bloÄŸunda ,
select user_name  from account where id=5; --> profelis
paralelde biri user_name gÃ¼nceller ise  tekrar select attÄ±ldÄ±ÄŸÄ±nda
select user_name  from account where id=5; --> profelis723  

3ï¸âƒ£ Phantom Read (Hayalet Okuma)

ğŸ”¸ Bir iÅŸlem, belirli bir filtreyle (Ã¶rneÄŸin â€œyaÅŸÄ± > 30 olanlarâ€) satÄ±rlarÄ± getirir.
ğŸ”¸ Daha sonra aynÄ± sorguyu tekrar Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±nda, baÅŸka bir iÅŸlem yeni satÄ±rlar eklediÄŸi iÃ§in gelen sonuÃ§ sayÄ±sÄ± deÄŸiÅŸmiÅŸ olabilir.
ğŸ”¸ Ä°lk sorguda olmayan satÄ±rlar â€œhayalet gibiâ€ gÃ¶rÃ¼nÃ¼r.

4ï¸âƒ£ Serialization Anomaly (SÄ±ralama TutarsÄ±zlÄ±ÄŸÄ±)
ğŸ”¸ Elimizde bir A bir B transaction olsun, Bu iki transaction farklÄ± sÄ±rada Ã§alÄ±ÅŸmasÄ± veriye farklÄ± sonuÃ§ gÃ¶sterecek ise , bu durumu Serialization Anomaly olarak isimlendirilmektedir.
ğŸ”¸Bu durum sadece Serializable seviye ile Ã¶nlenebilir.

âš ï¸ READ COMMITTED ->->-> SERIALIZABLE , soldan saÄŸa , sorgularÄ±n paralel Ã§alÄ±ÅŸma durumu  azalÄ±r ve lock yÃ¶netimi daha sÄ±klaÅŸtÄ±ÄŸÄ± iÃ§in perfomans dÃ¼ÅŸÃ¼sÃ¼ gÃ¶zÃ¼kecektir.

VarsayÄ±lan, Read committed ; 

mvcc kuralÄ±n, isolation seviyeleri;


/*--------------------------------------------------------------
ğŸŒhttps://www.postgresql.org/docs/current/explicit-locking.html
ğŸ”¶ Explicit-locking  / DoÄŸrudan kilitler
---------------------------------------------------------------

ğŸ”º PostgreSQL, tablolardaki verilere eÅŸzamanlÄ± eriÅŸimi kontrol etmek iÃ§in Ã§eÅŸitli kilit modlarÄ± bulunmakta.

ğŸ”ºMVCC, davranÄ±ÅŸÄ±ndan daha farklÄ± olarak eriÅŸimlere sÄ±nÄ±rlama getirmek istediÄŸimiz bu lock mekanizmasÄ± kullanmamÄ±z gerekmektedir.
AynÄ± ÅŸekilde DDL (data defination language) komutlarÄ±n yÃ¼rÃ¼tÃ¼lmesi iÃ§in arka plan postgres bu locklarÄ± kullanmaktadÄ±r. 

Ã–rn. alter table .. add column .. sÄ±rasÄ±nda postgres tabloya  ACCESS EXCLUSIVE lock tipi koyacaktÄ±r.

13.3. Explicit Locking #
13.3.1. Table-Level Locks  (tablo seviyesinde lock tÃ¼rleri) ğŸ’¥ğŸ’¥ğŸ’¥ 
13.3.2. Row-Level Locks (satÄ±r seviyesinde olan lock tÃ¼rleri) ğŸ’¥
13.3.3. Page-Level Locks (kullanÄ±cÄ± kullanamÄ±yor. ram ile disk arasÄ±nda page deÄŸiÅŸimlerinde.)
13.3.4. Deadlocks (aynÄ± datayÄ± modifiye eden durumda ortaya Ã§Ä±kÄ±yor.)  ğŸ’¥ğŸ’¥ğŸ’¥
13.3.5. Advisory Locks (uygulama lock tÃ¼rleri)


â­•ï¸ 13.3.1. Table-Level Locks 

ğŸ”º TÃ¼m tabloyu etkileyecek ÅŸekilde eriÅŸim sÄ±nÄ±rlamasÄ± getiren lock tipleridir.

âš ï¸ KullanÄ±cÄ±lar farkÄ±nda olmadan arka planda postgres bu locklarÄ± yÃ¼rÃ¼teceÄŸi iÃ§in bu lock tip hangi durumlarda ne seviyede eriÅŸim kÄ±sÄ±tÄ± getirdiÄŸi iyi anlaÅŸÄ±lmalÄ±. Ã‡alÄ±ÅŸan transactionlar, Production ortamÄ±nda oluÅŸan kilitler ile sorgularda yanÄ±t alamama durumu oluÅŸabilir.

8 tane table-level lock modumuz bulunmakta.
1. ACCESS SHARE (AccessShareLock) ğŸ’¥ tablo Ã¼zerinde deÄŸiÅŸklik yapamÄ±yoruz. veri insert. 
2. ROW SHARE (RowShareLock)
3. ROW EXCLUSIVE (RowExclusiveLock)
4. SHARE UPDATE EXCLUSIVE (ShareUpdateExclusiveLock)
5. SHARE (ShareLock)
6. SHARE ROW EXCLUSIVE (ShareRowExclusiveLock)
7. EXCLUSIVE (ExclusiveLock)
8. ACCESS EXCLUSIVE (AccessExclusiveLock)   ğŸ’¥ğŸ’¥ğŸ’¥ okuma yazmayÄ± engelliyor 


1ï¸âƒ£ACCESS SHARE (AccessShareLock)
Ne zaman alÄ±nÄ±r?: The SELECT command acquires a lock of this mode / cOPY to

Kimle Ã§akÄ±ÅŸÄ±r?: Conflicts with the ACCESS EXCLUSIVE lock mode only.
AmaÃ§: In general, any query that only reads a table and does not modify it will acquire this lock mode.

Select sorgu attÄ±ÄŸÄ±mÄ±z tablolarÄ±n Ã¼zerine gÃ¶rÃ¼len lock tipidir.
DiÄŸer sorgularÄ±n tabloyu okumasÄ±na izin verir ama tablo yapÄ±sÄ±nda deÄŸiÅŸiklik yapmasÄ±na izin vermez.

YalnÄ±zca "ACCES EXCLUSIVE" ile Ã§akÄ±ÅŸma yaÅŸanÄ±yor bu lock tipinde.
yani bir tablo select sorgusu Ã§alÄ±ÅŸÄ±yor ise.

ÅŸu komutlarÄ±n paralelde Ã§alÄ±ÅŸtÄ±ramayacaÄŸÄ±zdÄ±r.
DROP TABLE, TRUNCATE, REINDEX, CLUSTER, VACUUM FULL,
and REFRESH MATERIALIZED VIEW (without CONCURRENTLY) commands. 
Many forms of ALTER INDEX and ALTER TABLE also acquire a lock at this level.

*/*/

create table if not exists test_lock (c1 int);
insert into test_lock select generate_Series(1,10);


select locktype,database,relation,mode
from pg_locks order by page desc nulls last;

-- hangi tablo olduÄŸunu anlamak iÃ§in. 

select * from pg_class limit 10  --> catalog tablomuzda yararlanalÄ±m.

select t2.relname,t1.mode
from pg_locks t1 
join pg_class t2 on t1.relation=T2.oid order by relname desc  


https://docs.google.com/spreadsheets/d/1REviu5GLkic4_PA506yMtm1ZHCj__sjxk-uZf154HbY/edit?gid=0#gid=0

/*
âš ï¸ tabloya eriÅŸimi tamamen engelleyen komutlardan bazÄ±larÄ± "ACCESS EXCLUSIVE"
DROP TABLE
TRUNCATE
REINDEX
CLUSTER
VACUUM FULL
REFRESH MATERIALIZED VIEW
ALTER TABLE ADD COLUMN
ALTER TABLE DROP COLUMN
ALTER TABLE SET DATA TYPE
ALTER TABLE SET/DROP DEFAULT
ALTER TABLE DROP EXPRESSION
ALTER TABLE ALTER CONSTRAINT 
ALTER TABLE DROP CONSTRAINT
ALTER TABLE RENAME



create index  concurrently;

concurrently parametresi alan komutlar, sistemde hafif lock koymaktadÄ±r.


-- locklayan bir sorgunu tespiti 

SELECT
	    pid,
	    datname,
	    usename,
	    application_name,
	    client_addr,
	    pg_catalog.to_char(backend_start, 'YYYY-MM-DD HH24:MI:SS TZ') AS backend_start,
	    state,
	    wait_event_type || ': ' || wait_event AS wait_event,
	    array_to_string(pg_catalog.pg_blocking_pids(pid), ', ') AS blocking_pids,
	    query,
	    pg_catalog.to_char(state_change, 'YYYY-MM-DD HH24:MI:SS TZ') AS state_change,
	    pg_catalog.to_char(query_start, 'YYYY-MM-DD HH24:MI:SS TZ') AS query_start,
	    pg_catalog.to_char(xact_start, 'YYYY-MM-DD HH24:MI:SS TZ') AS xact_start,
	    backend_type,
	    CASE WHEN state = 'active' THEN ROUND((extract(epoch from now() - query_start) / 60)::numeric, 2) ELSE 0 END AS active_since
	FROM
	    pg_catalog.pg_stat_activity
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 5)ORDER BY pid


select pg_terminate_backend(1697);

*/*
--13.3.4. Deadlocks 

Deadlock (kilitlenme), iki (veya daha fazla) iÅŸlemin (transactionâ€™Ä±n) birbirinden kaynaklÄ± olarak sonsuz beklemeye girmesi durumudur. Her biri, diÄŸerinin kilitlediÄŸi kaynaÄŸa ihtiyaÃ§ duyar ama hiÃ§biri geri adÄ±m atmaz. SonuÃ§? Sonsuz bekleme, yani deadlock.

GerÃ§ekleÅŸme durumu ?
Transaction A, veri satÄ±rÄ± Xâ€™i kilitler.
Transaction B, veri satÄ±rÄ± Yâ€™yi kilitler.
Transaction A, Yâ€™yi de kilitlemeye Ã§alÄ±ÅŸÄ±r   â¡ ama B zaten kilitlediÄŸi iÃ§in bekler.
Transaction B, Xâ€™i kilitlemeye Ã§alÄ±ÅŸÄ±r â¡  ama A kilitlediÄŸi iÃ§in o da bekler.

Bu durumda iki iÅŸlem birbirini kilitler, PostgreSQL bunu fark eder ve birini iptal ederek deadlockâ€™Ä± Ã§Ã¶zer.

-- > postgresql.conf
show deadlock_timeout;
alter system set deadlock_timeout to '1hour';
select * from pg_settings where name ='deadlock_timeout'; 

-- BÃ¶lÃ¼m -3 bgwriter and checkpointer

select * from pg_database ;

select relfilnode,* from pg_class limit 10  --> index, view, tablo, 

test_lock, 16389

10gb tablo olduÄŸunda 

16389
16389.1
16389.2

Disk -> base -> (1gb) file segment  -> data_pages (8kb) ->  8byte
ramde -> en bÃ¼yÃ¼k postgres shared_buffers postgresin yÃ¶nettiÄŸi cache alanÄ±. 
disk data_pages(8kb) <-> linux cache  <-> shared_buffer (8kb) (buffer_page)
disk dirty_page , 
shared_buffer dirty_buffer


-- Postgresql Ã‡alÄ±ÅŸan Processler
-- ğŸŒ https://www.postgresql.org/docs/current/glossary.html#GLOSSARY-AUXILIARY-PROC

/*
A process within an instance that is in charge of some specific background task for the instance. 
The auxiliary processes consist of 
the autovacuum launcher (but not the autovacuum workers), 
the background writer , (+) 
the checkpointer,  (+)
the logger, 
the startup process, 
the WAL archiver, 
the WAL receiver (but not the WAL senders), and 
the WAL writer.
*/

select distinct backend_Type from pg_stat_activity; 

select * from pg_stat_activity;  --> sistem anlÄ±k ne Ã§alÄ±ÅŸÄ±yor ? 


-- ğŸ”´ PostgreSQLâ€™de bgwriter ve checkpointer ğŸ”´
--------------------------------------------------
1.Checkpointer ( yaptÄ±ÄŸÄ± iÅŸ: checkpoint ,dirty page temizleme)
2.Background writer   ( yaptÄ±ÄŸÄ± iÅŸ: dirty page temizleme)


/*----------------------------------------
ğŸŒ https://www.postgresql.org/docs/current/glossary.html#GLOSSARY-CHECKPOINTER


â­•ï¸ CHECKPOINTER (process)
----------------------------------------
ğŸ”¸An auxiliary process that is responsible for executing checkpoints.

"CHEKCPOINT" iÅŸlemini gerÃ§ekleÅŸtirmeden sorumlu yardÄ±mcÄ± process.

ğŸŒ https://www.postgresql.org/docs/16/glossary.html#GLOSSARY-CHECKPOINT
â­•ï¸ Checkpoint  Wal,dirty buffer, ram - sync - disk

shared_buffer dirty_buffer lar birikiyor, 

checkpointer ->  shared_buffer, dirty_pagelerimiZ -> diske yazÄ±lÄ±yor.
t anÄ± pg_Wal wal dosyasÄ±na not olarak dÃ¼ÅŸÃ¼lÃ¼yor.

ğŸ”ºcheckpointer -> checkpoint tetiklendiÄŸinde shared bufferdaki dirty bufferlarÄ±n tamamÄ± (deÄŸiÅŸikliÄŸe uÄŸramÄ±ÅŸ data pages) diske yazÄ±lma sÃ¼reci baÅŸlar. ve memory ile diskteki veri sync durumuna geldiÄŸi t anÄ±nda checkpoint noktasÄ± olarak wal dosyasÄ±na yazÄ±lÄ±r.

ğŸ”ºBu sayede crash anÄ±nda en son gerÃ§ekleÅŸen checkpoint noktasÄ±ndan itibaren wal dosyalarÄ± tekrardan okunarak veri bÃ¼tÃ¼nlÃ¼ÄŸÃ¼ne eriÅŸilmiÅŸ olur. Crash recovery sÃ¼resini kÄ±saltÄ±r. 
Recovery time objective (RTO) sÃ¼resi.

ğŸ”ºCheckpointer, checkpoint_timeout ve max_wal_size parametrelerine gÃ¶re checkpoint sÃ¼recini baÅŸlatÄ±r.

ğŸ”ºCheckpoint sÃ¼reci baÅŸladÄ±ÄŸÄ±nda memorydeki tÃ¼m dirty bufferlarÄ± diske yazÄ±lmasÄ± iÅŸlemi baÅŸlayacaÄŸÄ± iÃ§in sistemde yÃ¼ksek I/O yÃ¼kÃ¼ âš ï¸ oluÅŸturabilir. Bu nedenle, bu yÃ¼kÃ¼n parametreler aracÄ±lÄ±ÄŸÄ±yla zamana yayÄ±lmasÄ± ve daha yatay, dengeli bir I/O grafiÄŸi oluÅŸturacak ÅŸekilde yapÄ±landÄ±rÄ±lmasÄ± Ã¶nerilir.

Ã–zet: Checkpointer, checkpoint sÃ¼recini baÅŸlatÄ±r,dirty bufferlarÄ±mÄ±z diske yazÄ±lÄ±r ve wal loglarÄ±na bu t anÄ±nÄ±n zamanÄ± kaydÄ± yazÄ±lÄ±r.
*/

select name,setting,unit,short_Desc,category 
from pg_settings where short_Desc like '%checkpoint%';
-- checkpoint sÃ¼reci ile alakalÄ± parametreler.


/*----------------------------------------
ğŸŒ https://www.postgresql.org/docs/16/runtime-config-wal.html#RUNTIME-CONFIG-WAL-CHECKPOINTS 
â­•ï¸ Checkpointer ayarlarÄ±. 
----------------------------------------

CHECKPOINT komutu Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda
PostgreSQL servisi durdurulduÄŸunda  (immediate olarak durdurulmadÄ±ÄŸÄ±nda)
, yedekten dÃ¶nÃ¼ÅŸ yapÄ±ldÄ±ÄŸÄ±nda
VeritabanÄ± oluÅŸturma, silme

VeritabanÄ± tablespace ler arasÄ±nda taÅŸÄ±ndÄ±ÄŸÄ±nda
pg_start_backup komutu iÅŸletildiÄŸinde 

checkpoint_timeout sÃ¼resi dolduÄŸunda
max_wal_size deÄŸerine eriÅŸildiÄŸinde


https://github.com/postgres/postgres/blob/master/src/backend/utils/misc/postgresql.conf.sample

# - Checkpoints -
#checkpoint_timeout = 5min		# range 30s-1d
#checkpoint_completion_target = 0.9	# checkpoint target duration, 0.0 - 1.0
#checkpoint_flush_after = 0		# measured in pages, 0 disables
#checkpoint_warning = 30s		# 0 disables
#max_wal_size = 1GB
#min_wal_size = 80MB



ğŸ”¶checkpoint_timeout (integer) (varsayÄ±lan 5min)
Maximum time between automatic WAL checkpoints. 
If this value is specified without units, it is taken as seconds. 
The valid range is between 30 seconds and one day. 
The default is five minutes (5min). 
Increasing this parameter can increase the amount of time needed for crash recovery.
This parameter can only be set in the postgresql.conf file 
or on the server command line.

ğŸ”¸ Checkpointer Process, son gerÃ§ekleÅŸen checkpoint Ã¼zerinden checkpoint_timeout parametresi belirlenen zaman geÃ§miÅŸ ise  checkpoint sÃ¼recini baÅŸlatÄ±r.


â„¹ï¸ Bu parametrenin artÄ±rÄ±lmasÄ± â¬†ï¸, Ã§Ã¶kme (crash) sonrasÄ± veritabanÄ±nÄ±n yeniden hazÄ±r duruma gelme sÃ¼resini (recovery time) uzatabilir.
Buna karÅŸÄ±lÄ±k, azaltÄ±lmasÄ± â¬‡ï¸ ise daha sÄ±k checkpoint oluÅŸmasÄ±na neden olarak disk Ã¼zerinde I/O yÃ¼kÃ¼nÃ¼ artÄ±racaktÄ±r.

ğŸ”¶checkpoint_completion_target (integer) (varsayÄ±lan 0.9)  v13 0.5

ğŸ”¸ Checkpoint sÄ±rasÄ±nda bellek Ã¼zerindeki "dirty buffer"larÄ±n (deÄŸiÅŸikliÄŸe uÄŸramÄ±ÅŸ sayfalar) diske yazÄ±lmasÄ±, ani bir I/O yÃ¼kÃ¼ oluÅŸturmamasÄ± iÃ§in zaman yayÄ±lmasÄ±nÄ± saÄŸlar.

checkpoint_timeout 5dk , sÃ¼recin 4dk lÄ±k kÄ±smÄ±nda yazma iÅŸle gerÃ§ekleÅŸecek, checkpoint -> pg_wal

checpoint tamamlandÄ±, 5dk uyuyor, checkpoint tetikleniyor.

checkpoint tetikleniyor. 5dk Ã§alÄ±ÅŸacak ,  4dk  (checkpoint_completion_target , 1dk boÅŸta checkpoint,  uykuya dalmÄ±ÅŸ 5dk uyama,


ğŸ”¶ max_wal_size (integer)  default: 1GB

ğŸ”¸En son yapÄ±lan checkpoint noktasÄ±ndan itibaren max_wal_size bÃ¼yÃ¼klÃ¼ÄŸÃ¼nde wal dosyasÄ± yazÄ±lÄ±r ise, checkpoint tetiklenir.

â˜¢ï¸ bu parametre soft limitdir. Ä°sminde max_wal_size geÃ§mesi maximum pg_wal dizininde birekecek loglarÄ±n boyutunu sabit tutmayabilir.

âš ï¸ checkpoint sÃ¼recinin ,max_wal_size yerine checkpoint_timeout ile tetiklenmesi beklenir bu sayade I/O yÃ¼kÃ¼ checkpoint_timeout ile tetiklenerek daha az dalganmalar ile zamana yayÄ±lmÄ±ÅŸ olur.

log kaydÄ±nda;
checkpoint starting: wal ÅŸeklinde kayÄ±tlar Ã§ok fazla gÃ¶zÃ¼kÃ¼yor ise. max_wal_size boyutu yÃ¼ksetilmesi dÃ¼ÅŸÃ¼nÃ¼lmelidir.
LOG:  checkpoints are occurring too frequently (4 seconds apart)
HINT:  Consider increasing the configuration parameter "max_wal_size".
LOG:  checkpoint starting: wal 


min_wal_size <  wal_dizini < max_wal_size (wal_keep_size)  Ã¼st limit 

archive_command aÃ§Ä±k deÄŸil ise  archive baÅŸarÄ±lÄ± olsayaa kadar waller silmeyecektir.


Bir diÄŸer seÃ§enek. log kayÄ±tlarÄ±na cat * | grep "checkpoint" ÅŸeklinde tarama yapÄ±larak. dÃ¼ÅŸen loglarda
checkpoint starting: time
checkpoint starting: time
checkpoint starting: time
gÃ¶zÃ¼kmesi beklenir. 
checkpoint starting: wal  kaydÄ±nÄ±n daha az gÃ¶rÃ¼lmesi iÃ§in 
alter system max_wal_size to '100GB'; select pg_reload_conf();

pg_wal <- max_Wal_Size (100GB) <- wal_keep_Size (500GB) replikasyon dizginliyebilyor.

Checkpoint, shared_bufferda update/delete/insert iÅŸlemlerinden etkilenen tablolarÄ±, kalÄ±cÄ± deÄŸiÅŸiklerini diske yazÄ±yor. dirty_pages -> disk

â“â“â“
checkpoint sÃ¼remizi 15dk ayarladÄ±k. shared_bufferda update/delete/insert iÅŸlemleri shared_buffer'daki alanÄ±mÄ±zÄ± doldurduÄŸunda ne yaÅŸanÄ±yor. 
â“â“â“

client_backend , shared_buffer yer kalmadÄ±ÄŸÄ± durumda, drity_buffer temizliÄŸini Ã¼stlenir. 

/*----------------------------------------
ğŸŒhttps://www.postgresql.org/docs/16/runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-BACKGROUND-WRITER
â­•ï¸ Background writer, bgwriter , lazy writer 
----------------------------------------


select name,setting,short_desc from pg_Settings where name like '%bgwriter%';
*/*/
-- BgwriterHibernate uyku modunda
select wait_Event_type,wait_event,backend_Type,* 
from pg_stat_Activity where backend_type='background writer';

There is a separate server process called the background writer, 
whose function is to issue writes of â€œdirtyâ€ (new or modified) shared buffers. 
When the number of clean shared buffers appears to be insufficient, 
the "background writer" writes some dirty buffers to the file system and marks them as clean. 
This reduces the likelihood that server processes handling "user queries will be unable to find clean buffers and have to write dirty buffers themselves" 

/*

ğŸ”¸bgwriter_delay (integer)  default 200 ms -> 20ms

Background Writer (bgwriter), her 200 ms'de bir tetiklenerek temizlenmesi gereken dirty page'ler var mÄ± diye kontrol eder.

ğŸ”¸bgwriter_lru_maxpages default 100  -> 500

bgwriter tetiklendiÄŸinde maxiumum ne kadar page temizleyeceÄŸi. 

ğŸ”¸ bgwriter_lru_multiplier	default 2 
Bir Ã¶nceki turda yazÄ±lan dirty page sayÄ±sÄ±nÄ± bu Ã§arpan kadar katÄ±nÄ± temizler.

Bu sayede bgwriter, sistem yoÄŸun yÃ¼k altÄ±ndayken daha agresif, dÃ¼ÅŸÃ¼k yÃ¼kteyken ise daha sakin Ã§alÄ±ÅŸÄ±r.
*/*/

select pg_size_pretty(8096*500::numeric*50)

-- select * from pg_stat_bgwriter; Ã¼zerinde maxwritten_clean zamanla hÄ±zlÄ± yÃ¼kselme eÄŸilimnde olmamasÄ± gerekir.

-- âš ï¸ EÄŸer maxwritten_clean deÄŸeri hÄ±zlÄ± yÃ¼kseliÅŸte ise, bu bgwriterâ€™Ä±n sayfa yazma sÄ±nÄ±rÄ±na sÄ±k sÄ±k ulaÅŸtÄ±ÄŸÄ±nÄ± belirtisidir. 

Not:
bgwriter_lru_multiplier yÃ¼kseltilebilir. 2->4
bgwriter_delay azaltÄ±labilir. 200ms -> 20ms
bgwriter_lru_maxpages yÃ¼sektilebilir -> 100 -> 500

/*----------------------------------------------------------------
ğŸŒ https://www.postgresql.org/docs/current/maintenance.html
â­•ï¸ Postgresde ileri dÃ¼zey bakÄ±m iÅŸlemleri
------------------------------------------------------------------

PostgreSQL, like any database software, 
requires that certain tasks be performed regularly to achieve optimum performance. 

ğŸ”¸ PostgreSQL, diÄŸer veritabanÄ± sistemleri gibi belirli bakÄ±m iÅŸlemlerinin dÃ¼zenli olarak yÃ¼rÃ¼tÃ¼lmesini gerektirir.

Bu sayede, veritabanÄ±nÄ±n performansÄ± optimum seviyede tutulabilir.

PostgreSQL is low-maintenance compared to some other database management systems. 
Nonetheless, appropriate attention to these tasks will  
go far towards ensuring a pleasant and productive experience with the system.

ğŸ”¸PostgreSQL, diÄŸer bazÄ± veritabanÄ± sistemleriyle karÅŸÄ±laÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda daha az bakÄ±m ihtiyacÄ± duyar. Ancak, yÃ¼ksek performanslÄ± ve sÃ¼rdÃ¼rÃ¼lebilir bir sistem hedefliyorsak bu bakÄ±m sÃ¼reÃ§lerin saÄŸlÄ±klÄ± ÅŸekilde yÃ¼rÃ¼tÃ¼lmesine gereken Ã¶nemi mutlaka vermeliyiz.

24.1. Routine Vacuuming 
24.2. Routine Reindexing


/*----------------------------------------------------------------
ğŸŒ https://www.postgresql.org/docs/16/routine-vacuuming.html 
â­•ï¸ vacuum rutini
------------------------------------------------------------------
PostgreSQL databases require periodic maintenance known as vacuuming. 
For many installations, it is sufficient to let vacuuming be performed by the autovacuum daemon.

ğŸ”ºPostgresql dÃ¼nyasÄ±nda, yapÄ±lan bakÄ±m iÅŸlemlerine "vacuuming" olarak isimlendirilmektedir. 

ğŸ”ºBu iÅŸlemi arka tarafta postgresql server baÅŸladÄ±ÄŸÄ±nda Ã§alÄ±ÅŸmaya baÅŸlayan "autovacuum daemon" otomatik olarak gerÃ§ekleÅŸmesi saÄŸlamaktadÄ±r.

Some database administrators will want to supplement or 
replace the daemon's activities with manually-managed VACUUM commands,

ğŸ”ºAutovacuum daemon, birÃ§ok durumda yeterli olsa da, manuel vacuum komutu ile desteklenmesi gerekebilir.

ğŸ”º Bu eÄŸitimin ilerleyen bÃ¶lÃ¼mlerinde, manuel vacuum iÅŸlemlerinin hangi durumlarda gerekli olabileceÄŸini birlikte yorumlayacak ve ilgili bilgilere detaylÄ± ÅŸekilde deÄŸineceÄŸiz.


25.1.1. Vacuuming Basics 
PostgreSQL's VACUUM command has to process each table on a regular basis for several reasons:

1. To recover or reuse disk space occupied by updated or deleted rows.
2. To update data statistics used by the PostgreSQL query planner.
3. To update the visibility map, which speeds up index-only scans.
4. To protect against loss of very old data due to transaction ID wraparound 
or multixact ID wraparound.

VACUUM komutu sayesinde:

ğŸ”¹ Update veya delete iÅŸlemleri sonucu oluÅŸan hayelet satÄ±rlarÄ±n kapladÄ±ÄŸÄ± disk alanÄ±nÄ± geri kazandÄ±rÄ±r.

ğŸ”¹ Ä°statistikleri gÃ¼ncelleyerek, sorgu planlayÄ±cÄ±sÄ±nÄ±n daha doÄŸru kararlar almasÄ±nÄ± ve sorgularÄ±n daha hÄ±zlÄ± Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlar.

ğŸ”¹ Visibility Map'i gÃ¼nceller, bu da index-only scan (sadece index kullanÄ±larak yapÄ±lan taramalar) taramasÄ±nÄ±n gerÃ§ekleÅŸmesini saÄŸlar.

ğŸ”¹ Transaction ID sarmalanmasÄ± (ID wraparound) nedeniyle oluÅŸabilecek veri kaybÄ±nÄ± Ã¶nler.


VACUUM sÃ¼reÃ§leri, ya performans iyileÅŸtirmesi saÄŸlar ya da oluÅŸabilecek felaketlerin Ã¶nÃ¼ne geÃ§er.


â­•ï¸ Recovering Disk Space 

In PostgreSQL, an UPDATE or DELETE of a 
row does not immediately remove the old version of the row. 
This approach is necessary to gain the benefits of multiversion concurrency control 
(MVCC, see Chapter 13): the row version must not be deleted while it is 
still potentially visible to other transactions. 
But eventually, an outdated or deleted row version is no longer of 
interest to any transaction. The space it occupies must then be reclaimed 
for reuse by new rows, to avoid unbounded growth of disk space requirements.
This is done by running VACUUM.

vacuum table_name ;  dead_tuple tekrar kullanÄ±bilir

ğŸ”º DISK ALANININ GERI KAZANILMASI 

Postgres "MVCC" yapÄ±sÄ± gereÄŸi modifiye edilen satÄ±rÄ± diÄŸer transactionlar 
tarafÄ±ndan hala gÃ¶rÃ¼lebilir olacaÄŸÄ± iÃ§in sistemden kaldÄ±rmÄ±yor. BunlarÄ± "dead_tuple"
olarak iÅŸaretliyor.

Bir sÃ¼re sonra bu eski versiyonlarÄ±n diÄŸer transactionlar iÃ§inde anlamÄ± olmayacaÄŸÄ± 
iÃ§in boÅŸ yere diskte yer kaplamÄ±ÅŸ olacaklardÄ±r.

Bu "dead_tuple" larÄ±n tabloda Ã§ok fazla birikmesi sonucu oluÅŸan ve
geri kullanÄ±ma kazanÄ±lmayan alan sorununa Postgres dÃ¼nyasÄ±nda ğŸ’¥BLOATğŸ’¥ olarak isimlendirilir.

Bloat durumununun oluÅŸmamasÄ± iÃ§in "VACUUM" sÃ¼reÃ§inin deÄŸiÅŸiklik olan tablolarda yÃ¼rÃ¼tÃ¼lmesi gerekir.

Normal koÅŸullarda bu iÅŸlem, autovacuum mekanizmasÄ± tarafÄ±ndan otomatik olarak gerÃ§ekleÅŸtirilir.

Ancak veritabanÄ±mÄ±zÄ±n saÄŸlÄ±klÄ± ÅŸekilde iÅŸlediÄŸinden emin olmak iÃ§in, autovacuum'un gÃ¶revini yerine getirip getirmediÄŸini zaman zaman manuel olarak kontrol etmek faydalÄ± olacaktÄ±r.

ğŸ“– Vacuum komutu nasÄ±l etki ediyor, ve bloat sorunu nedir incelemek iÃ§in Ã¶rnekler yapalÄ±m.  

ğŸŒ https://www.postgresql.org/docs/16/monitoring-stats.html#MONITORING-PG-STAT-ALL-TABLES-VIEW

ğŸ”¸ Bu durumu tespit etmede yardÄ±mcÄ± olacak istatiksel tablolar ve sorgular 
*/*/
/*
alter system set autovacuum to off; select pg_Reload_conf();
select distinct backend_type from pg_stat_activity; --> autovacuum launcer gÃ¶zÃ¼kmÃ¼yor.
*/

create table test_bloat (c1 int) ;

select n_tup_del,n_tup_ins,n_live_tup,n_dead_tup,n_ins_since_vacuum 
from pg_stat_user_tables where relname ='test_bloat'; --> tabloma ait bir takÄ±m bilgiler 0

-- ğŸŒhttps://www.postgresql.org/docs/16/functions-admin.html#FUNCTIONS-ADMIN-DBOBJECT
select pg_total_relation_size('test_bloat'); --> tablomun boyutu 0 

insert into test_bloat select generate_Series(1,1_000_000);

select relid,n_tup_del,n_tup_ins,n_live_tup,n_dead_tup,n_ins_since_vacuum 
from pg_stat_user_tables where relname ='test_bloat'; --> tabloma ait bir takÄ±m bilgiler

select pg_total_relation_size('test_bloat'); --> tablomun boyutu 36282368 byte
select pg_size_pretty(pg_total_relation_size('test_bloat')); --> 35 MB tablomun boyutu.

insert into test_bloat select generate_Series((1000000*1)+1,1000000*2); --1m satÄ±r daha 

select relid,n_tup_del,n_tup_ins,n_live_tup,n_dead_tup,n_ins_since_vacuum 
from pg_stat_user_tables where relname ='test_bloat'; --> tabloma ait bir takÄ±m bilgiler

select pg_size_pretty(pg_total_relation_size('test_bloat')); --> 69 MB tablomun boyutu.

-- aradan bir satÄ±rlar sileceÄŸim

delete from test_bloat where c1 > 500000 and c1 <= 750000; --250bin satÄ±r silelim


select relid,n_tup_del,n_tup_ins,n_live_tup,n_dead_tup,n_ins_since_vacuum 
from pg_stat_user_tables where relname ='test_bloat'; --> tabloma ait bir takÄ±m bilgiler 

--n_dead_tup 250000	gÃ¶zÃ¼kÃ¼yor.
select pg_size_pretty(pg_total_relation_size('test_bloat')); --> silme iÅŸleminde sonra tablo boyutu deÄŸiÅŸmedi.
-- â„¹ï¸bu adÄ±mda bloat oluÅŸmaya baÅŸlamÄ±ÅŸ oldu. tablo Ã¼zerinde iÅŸimize kullanÄ±m dÄ±ÅŸÄ± kalan alan oluÅŸtu.

-- sildiÄŸim satÄ±rlarÄ± geri insert etsem ne olacak ? 
insert into test_bloat select generate_Series(500001,750000);

select relid,n_tup_del,n_tup_ins,n_live_tup,n_dead_tup,n_ins_since_vacuum 
from pg_stat_user_tables where relname ='test_bloat'; --> tabloma ait bir takÄ±m bilgiler 

--n_dead_up 250bin hala
select pg_size_pretty(pg_total_relation_size('test_bloat')); --> 78 MB Tablo daha fazla yer kapladÄ±.

-- âš ï¸ tabloda sildiÄŸimiz satÄ±rlarÄ±n yerine dolmadÄ±. sistemde yeni yer kaplamÄ±ÅŸ oldu. 

-- aynÄ± iÅŸlemi , delete , vacuum , insert ÅŸeklinde tekrar deneyelim ne olacak ?

truncate table test_bloat
select pg_stat_reset()  --> istatik tablolarÄ±n resetleme komutu

select relid,n_tup_del,n_tup_ins,n_live_tup,n_dead_tup,n_ins_since_vacuum 
from pg_stat_user_tables where relname ='test_bloat'; --> tabloma ait bir takÄ±m bilgiler 

insert into test_bloat select generate_Series(1,1000000);
insert into test_bloat select generate_Series((1000000*1)+1,1000000*2); --1m satÄ±r daha insert


select relid,n_tup_del,n_tup_ins,n_live_tup,n_dead_tup,n_ins_since_vacuum 
from pg_stat_user_tables where relname ='test_bloat'; --> tabloma ait bir takÄ±m bilgiler 

16395	0	2000000	2000000	0	2000000

select pg_size_pretty(pg_total_relation_size('test_bloat')); --> 69 MB Tablo .

delete from test_bloat where c1 > 500000 and c1 <= 750000; --250bin satÄ±r silelim

select relid,n_tup_del,n_tup_ins,n_live_tup,n_dead_tup,n_ins_since_vacuum 
from pg_stat_user_tables where relname ='test_bloat'; --> tabloma ait bir takÄ±m bilgiler 

--n_dead_tup 250bin
select pg_size_pretty(pg_total_relation_size('test_bloat')); --> 69 MB Tablo silme iÅŸlemi olduÄŸu halde .

vacuum ( verbose ) test_bloat;
/*
INFO:  vacuuming "egitim_723.public.test_bloat"
INFO:  finished vacuuming "egitim_723.public.test_bloat": index scans: 0
pages: 0 removed, 8850 remain, 8850 scanned (100.00% of total)
tuples: ğŸ’¥250000 removedğŸ’¥, 1750000 remain, 0 are dead but not yet removable
removable cutoff: 805, which was 0 XIDs old when operation ended
new relfrozenxid: 802, which is 1 XIDs ahead of previous value
frozen: 2 pages from table (0.02% of total) had 182 tuples frozen
index scan not needed: 1107 pages from table (12.51% of total) had 250000 dead item identifiers removed
avg read rate: 0.000 MB/s, avg write rate: 42.298 MB/s
buffer usage: 17707 hits, 0 misses, 459 dirtied
WAL usage: 11067 records, 1109 full page images, 2186614 bytes
system usage: CPU: user: 0.08 s, system: 0.00 s, elapsed: 0.08 s
VACUUM
*/

-- tablo Ã¼zerindeki 250000 dead_tuple tekrar kullanÄ±ma aÃ§Ä±lmÄ±ÅŸ oldu. 

select relid,n_tup_del,n_tup_ins,n_live_tup,n_dead_tup,n_ins_since_vacuum 
from pg_stat_user_tables where relname ='test_bloat'; --> tabloma ait bir takÄ±m bilgiler 


-- n_dead_tup gÃ¶zÃ¼kmÃ¼yor artÄ±k tablomda .
select pg_size_pretty(pg_total_relation_size('test_bloat')); --> 69 MB .

-- insert iÅŸlemini gerÃ§ekleÅŸtiriyorum.
-- sildiÄŸim satÄ±rlarÄ± geri insert etsem ne olacak ? 
insert into test_bloat select generate_Series(500001,750000);

select relid,n_tup_del,n_tup_ins,n_live_tup,n_dead_tup,n_ins_since_vacuum 
from pg_stat_user_tables where relname ='test_bloat'; --> tabloma ait bir takÄ±m bilgiler 

select pg_size_pretty(pg_total_relation_size('test_bloat')); --> 69 MB tablo boyutum yÃ¼kselmedi.


select  * from pg_Class where relname ='test_bloat' limit 10 


/* 
Burada vacuum iÅŸlemi ile tablo ait _fsm dosyasÄ±nda  data_pageler iÃ§indeki veri tutmaya mÃ¼sait alanlarÄ±n bilgisi gÃ¼ncelleniyor.

*/

-- select relfilenode from pg_class  where relname='test_bloat';
[postgres@localhost 16388]$ ls -larth  | grep 25336
rw-------. 1 postgres postgres  40K Nov  3 11:44 25336_fsm
rw-------. 1 postgres postgres 8.0K Nov  3 11:45 25336_vm
rw-------. 1 postgres postgres  70M Nov  3 11:49 25336


-- ğŸ§¹ VACUUM ile geri kazanÄ±lan alan, yalnÄ±zca tabloya gelecek yeni veriler iÃ§in kullanÄ±labilir hÃ¢le gelir.

-- ğŸ“Œ EÄŸer dead tuplelar olduÄŸu alan, tablomuzun son kÄ±sÄ±mlarÄ±nda yer alÄ±yorsa,  disk sistemi tarafÄ±ndan yeniden kullanÄ±ma aÃ§Ä±lÄ±r.  ğŸ’¥SHRINKğŸ’¥ .

--Senaryo:
Ã–rneÄŸin :
delete from .... where rec_time < current_Date - '1year'::interval;
tablomunuz %90 lÄ±k veri temizliÄŸi sonrasÄ±nda vacuum komutu Ã§alÄ±ÅŸtÄ± ama sistemin kullanÄ±ma aÃ§Ä±lmadÄ±ÄŸÄ±nÄ± gÃ¶rebiliriz.  

-- Bunu Ã¶rnek ile anlamaya Ã§alÄ±ÅŸalÄ±m.
-- truncate table test_bloat
-- select pg_stat_reset()

insert into test_bloat select generate_Series(1,1000000);
insert into test_bloat select generate_Series((1000000*1)+1,1000000*2); --1m satÄ±r daha insert

select relid,n_tup_del,n_tup_ins,n_live_tup,n_dead_tup,n_ins_since_vacuum 
from pg_stat_user_tables where relname ='test_bloat'; --> tabloma ait bir takÄ±m bilgiler 

select n_dead_tup from pg_stat_user_tables where relname ='test_bloat' limit 10 

select pg_size_pretty(pg_total_relation_size('test_bloat')); --> 69 MB tablo 

-- aradan satÄ±rlar silelim

delete from test_bloat where c1 > 500000 and c1 <= 1000000;


select n_dead_tup from pg_stat_user_tables where relname ='test_bloat' --> 500.000

vacuum verbose test_bloat;

select n_dead_tup from pg_stat_user_tables where relname ='test_bloat' --> 0

select pg_size_pretty(pg_total_relation_size('test_bloat')); --> 69 MB tablo 

-- fiziksel olarak page bloÄŸun baÅŸÄ±nda emin olduÄŸum 250bin veriyi silelim

delete from test_bloat where c1 < 250000 ;

select n_dead_tup from pg_stat_user_tables where relname ='test_bloat' --> 249999


vacuum verbose test_bloat;

/*
INFO:  vacuuming "postgres.public.test_bloat"
INFO:  finished vacuuming "postgres.public.test_bloat": index scans: 0
pages: 0 removed, 8850 remain, 1108 scanned (12.52% of total)
tuples: ğŸ’¥249999ğŸ’¥ removed, 1312512 remain, 0 are dead but not yet removable
removable cutoff: 824358, which was 0 XIDs old when operation ended
frozen: 0 pages from table (0.00% of total) had 0 tuples frozen
index scan not needed: 0 pages from table (0.00% of total) had 0 dead item identifiers removed
avg read rate: 0.000 MB/s, avg write rate: 0.000 MB/s
buffer usage: 2227 hits, 0 misses, 0 dirtied
WAL usage: 2215 records, 0 full page images, 625277 bytes
system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s
VACUUM
*/

select n_dead_tup from pg_stat_user_tables where relname ='test_bloat' --> 0

select pg_size_pretty(pg_total_relation_size('test_bloat')); --> 69 MB tablo


-- sondan 250bin satÄ±rÄ± silmeyi deneyelim
delete from test_bloat where c1 > (select max(c1) - 250000 from test_bloat)  ;

vacuum verbose test_bloat;

select n_dead_tup from pg_stat_user_tables where relname ='test_bloat' --> 250000
vacuum verbose test_bloat;
/*

INFO:  vacuuming "postgres.public.test_bloat"
INFO:  table "test_bloat": truncated 8850 to 7744 pages
INFO:  finished vacuuming "postgres.public.test_bloat": index scans: 0
pages: ğŸ’¥1106 removedğŸ’¥, 7744 remain, 1107 scanned (12.51% of total)
tuples: ğŸ’¥250000 removedğŸ’¥, 1148419 remain, 0 are dead but not yet removable
removable cutoff: 824359, which was 1 XIDs old when operation ended
frozen: 0 pages from table (0.00% of total) had 0 tuples frozen
index scan not needed: 0 pages from table (0.00% of total) had 0 dead item identifiers removed
avg read rate: 0.000 MB/s, avg write rate: 0.000 MB/s
buffer usage: 3336 hits, 0 misses, 0 dirtied
WAL usage: 2217 records, 0 full page images, 625367 bytes
system usage: CPU: user: 0.01 s, system: 0.00 s, elapsed: 0.01 s
VACUUM
*/

select n_dead_tup from pg_stat_user_tables where relname ='test_bloat' --> 0
select pg_size_pretty(pg_total_relation_size('test_bloat')); --> 61MB boyut deÄŸiÅŸdi.

-- Ã‡ok yoÄŸun UPDATE ve DELETE iÅŸlemlerinin gerÃ§ekleÅŸtiÄŸi tablolarda, Ã¶zellikle de silinen veya gÃ¼ncellenen verilerin yerine aynÄ± oranda yeni veri gelmeyecekse, tabloda bloat (ÅŸiÅŸme) oluÅŸabilir.
/*

â“â“â“ bloat durumunda olan tablolarÄ± tespiti nasÄ±l gerÃ§ekleÅŸtirebiliriz  â“â“â“ 

VeritabanÄ±nmda bu durumda sistem kullanÄ±ma aÃ§acaÄŸÄ±m alana sahip tablolarÄ± nasÄ±l tespit ederiz ? 
Ne kadar  bloat durumuna  sahip olduÄŸunu bir tablonun  nasÄ±l anlarÄ±z ?

-- â­•ï¸ https://www.postgresql.org/docs/16/pgfreespacemap.html 
-- bloat table oranÄ±n tespit edilmesinde 1. yÃ¶ntem

create extension pg_freespacemap; 

-- eklentin gÃ¼ncel tablo bilgilerini alabilimesi vacuum Ã§alÄ±ÅŸmÄ±ÅŸ olmasÄ± gerekiyor. fsm tablosunu analiz ediyor.
*/
SELECT * FROM pg_freespace('test_bloat') where avail >0 ; --her bloktaki kullanÄ±labilir alan miktarÄ±

SELECT pg_size_pretty(count(*)*8*1024) total_size, --bir page 8kb veri tutulduÄŸuna gÃ¶re.
			 pg_size_pretty(sum(avail)) free_size, --> bloat size alanÄ±mÄ±z
			 pg_size_pretty(pg_relation_size('test_bloat')) -- tablonun boyutu
FROM pg_freespace('test_bloat') ; 

--https://www.postgresql.org/docs/17/pgstattuple.html --> bÃ¼yÃ¼k tablolarda yavaÅŸ Ã§alÄ±ÅŸÄ±yor.
create extension pgstattuple; --> pgstattubple 

select * from pgstattuple('test_bloat'); --> PostgreSQL'de bir tablonun gerÃ§ek doluluk oranÄ±nÄ±, boÅŸluklarÄ± ve Ã¶lÃ¼ satÄ±rlarÄ± doÄŸrudan fiziksel olarak tarayarak analiz eder. 

select *,pg_size_pretty(free_space) from pgstattuple('test_bloat'); 
-- tabloda sistemden ayrÄ±lan kaynak 26mb bÃ¼yÃ¼klÃ¼ÄŸÃ¼nde bloat durumu gÃ¶zlemleniyor.

--âš ï¸ Bloat durumun giderilmesi iÃ§in table ğŸ’¥rewriteğŸ’¥ iÅŸlemi gerÃ§ekleÅŸmesi gerekiyor.

A rewrite means a completely new copy of the table is created, and then the old one is dropped.

create table test_bloat_new as select * from test_bloat;
-- bu ÅŸekilde veriyi tekrardan yazÄ±lmasÄ±nÄ± saÄŸlarsam. yeni tablo iÃ§in tablodaki bloatsÄ±z veri alanÄ± kadar yer gerekecektir.

select *,pg_size_pretty(free_space) from pgstattuple('test_bloat')
union all
select *,pg_size_pretty(free_space) from pgstattuple('test_bloat_new')
-- yeni tabloda sistemden ayrÄ±lan kaynak gitti yani bloat durumu ortadan kalmÄ±ÅŸ oldu.

-- eski tabloyu droplayÄ±p , yeni tablonun ismini eski isimle deÄŸiÅŸtirebilirim.

-- Yeni Tablo oluÅŸturup verilerimizi taÅŸÄ±madan var olan bir tablo bloat durumunu nasÄ±l gideririz ?


/*
Tip
Plain VACUUM may not be satisfactory when a table contains large 
numbers of dead row versions as a result of massive update or delete activity.
If you have such a table and you need to reclaim the excess disk space it occupies,
you will need to use VACUUM FULL, 

vacuum table_name

vacuum full table_name;

or alternatively CLUSTER or one of the table-rewriting variants of ALTER TABLE. 
These commands rewrite an entire new copy of the table and build new indexes for it.
All these options require an ğŸ’¥ACCESS EXCLUSIVE lock.ğŸ’¥ 

ğŸ”¸ Postgres rewrite iÅŸlemi gerÃ§ekleÅŸtiren iki bakÄ±m komutu bulunmakta.
- vacuum full (tablodaki verilerin tekrardan diske yazÄ±lmasÄ±.)
- cluster     (tablodaki verilerin belirtilen indexe gÃ¶re ile tekrardan diske yazÄ±lmasÄ±.)

cluster table_name; --> not. tablo Ã¼zeirnde cluster index tanÄ±mÄ± Ã§alÄ±ÅŸmÄ±ÅŸ ise. vacuum full yerine tercih edilebilir.


â˜¢ï¸ rewrite iÅŸlemlerine uÄŸrayan tablolarda vacuum,analyze iÅŸlemi yÃ¼rÃ¼tÃ¼lmesi gerekir. AKSÄ° durumda sorgulardan beklenen perfomans gÃ¶rÃ¼lmeyecektir. â˜¢ï¸

1. adÄ±m  vacuum full table_name;
2. adÄ±m  vacuum analyze table_name;

*/
SELECT pg_size_pretty(count(*)*8*1024) total_size, --bir page 8kb veri tutulduÄŸuna gÃ¶re.
			 pg_size_pretty(sum(avail)) free_size, --> bloat size alanÄ±mÄ±z
			 pg_size_pretty(pg_relation_size('test_bloat')) -- tablonun boyutu
FROM pg_freespace('test_bloat') ; 

select * from pg_Stat_user_tables limit 10 

/*----------------------------------------------------------------
ğŸŒ https://www.postgresql.org/docs/17/sql-vacuum.html
â­•ï¸ vacuum komutu
-------------------------------------------------------------------

ğŸ”¸ FULL
Selects â€œfullâ€ vacuum, which can reclaim more space, but takes much longer and exclusively locks the table. This method also requires extra disk space, since it writes a new copy of the table and doesn't release the old copy until the operation is complete. Usually this should only be used when a significant amount of space needs to be reclaimed from within the table.

VACUUM FULL, hedef tablo Ã¼zerinde ACCESS EXCLUSIVE seviyesinde kilit alÄ±r.
Bu, iÅŸlem sÃ¼resince tabloya herhangi bir okuma veya yazma iÅŸleminin yapÄ±lamayacaÄŸÄ± anlamÄ±na gelir.

VACUUM FULL iÅŸlemi sÄ±rasÄ±nda tablo, tamamen yeniden yazÄ±lÄ±r.
Bu nedenle:
â€¢ Yeni tablo kopyasÄ± oluÅŸturulurken, diskte yeterli boÅŸ alanÄ±n bulunmasÄ± gerekir.
â€¢ Ä°ÅŸlem tamamlanana kadar, eski tablo kopyasÄ± silinmez.

10TB tablo ,  5TB alanÄ±n silindi. vacuum = 10TB

VACUUM FULL genellikle bÃ¼yÃ¼k miktarda boÅŸ alanÄ± geri kazanmak iÃ§in tercih edilir, ancak dikkatli planlanmalÄ± ve yoÄŸun saatlerde Ã§alÄ±ÅŸtÄ±rÄ±lmamalÄ±dÄ±r.
*/


SELECT pg_size_pretty(count(*)*8*1024) total_size, --bir page 8kb veri tutulduÄŸuna gÃ¶re.
			 pg_size_pretty(sum(avail)) free_size, --> bloat size alanÄ±mÄ±z
			 pg_size_pretty(pg_relation_size('test_bloat')) -- tablonun boyutu
FROM pg_freespace('test_bloat') ; --> 61MB, 26MB


select n_live_tup, vacuum_count from pg_stat_user_tables where relname='test_bloat'; 


vacuum (full,verbose) test_bloat; -- tablomuza vacuum full atalÄ±m ve bloat alanÄ±n sisteme kazandÄ±ralÄ±m.

select n_live_tup, vacuum_count from pg_stat_user_tables where relname='test_bloat'; 
/*
ğŸ”¸ vacuum_count yÃ¼kselmedi. 
ğŸ”¸ ğŸ’¥ğŸ’¥ vacuum full,cluster kullandÄ±ÄŸÄ±m durumda sonrasÄ±nda vacuum,analyze table_name iÅŸlemi gerÃ§ekleÅŸtirilmeli. 
*/

10 TB- 9TB bloat = 1tb gerÃ§ek verimiz var,  , 1TB veriye yazma sÃ¼resi boyunca kesinti olackatÄ±r. 
/*
Ã–ZET:

1ï¸âƒ£ MVCC (Multi-Version Concurrency Control) yapÄ±sÄ± gereÄŸi, veritabanÄ±ndan gerÃ§ekleÅŸen UPDATE ve DELETE iÅŸlemleri, dead_tuple olarak adlandÄ±rÄ±lan geÃ§ersiz satÄ±rlarÄ±n oluÅŸmasÄ±na neden olur.

2ï¸âƒ£ Bu satÄ±rlarÄ±n yeniden kullanÄ±labilir hale gelmesi iÃ§in PostgreSQLâ€™in VACUUM sÃ¼reci devreye girer.
VACUUM, free space map (FSM) yapÄ±sÄ±nÄ± gÃ¼ncelleyerek bu alanlarÄ±n tekrar veri yazÄ±mÄ± iÃ§in kullanÄ±lmasÄ±nÄ± saÄŸlar.

Ancak bu boÅŸluklar sayfa (page) sonlarÄ±nda yer alÄ±yorsa, PostgreSQL bu alanlarÄ± sistem kullanÄ±mÄ±na aÃ§abilir (SHRINK).

3ï¸âƒ£ EÄŸer tabloda Ã§ok sayÄ±da deÄŸiÅŸiklik iÅŸlemi gerÃ§ekleÅŸiyor ve oluÅŸan dead_tuple alanlarÄ± tablo tarafÄ±ndan tekrar kullanÄ±lmÄ±yorsa, tablo iÃ§erisinde bloat oluÅŸur.

Bu durumda, tabloyu baÅŸtan yazarak boÅŸ alanlarÄ± fiziksel olarak serbest bÄ±rakacak VACUUM FULL veya CLUSTER gibi komutlar kullanÄ±lmalÄ±dÄ±r.

âš ï¸ Bu iÅŸlemler tabloyu ACCESS EXCLUSIVE LOCK ile kilitler, yani iÅŸlem sÃ¼resince tabloya hiÃ§bir eriÅŸim yapÄ±lamaz.

4ï¸âƒ£ VACUUM FULL veya CLUSTER iÅŸlemlerinden sonra, PostgreSQLâ€™in sorgu planlayÄ±cÄ±sÄ±nÄ±n saÄŸlÄ±klÄ± Ã§alÄ±ÅŸmasÄ± iÃ§in VACUUM ANALYZE komutunun da yÃ¼rÃ¼tÃ¼lmesi Ã¶nerilir.

*/

















































































































































