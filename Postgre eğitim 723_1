EÄŸitim KonularÄ±

PostgreSQL Kurulumu
PostgreSQLâ€™de bgwriter ve checkpointer
PostgreSQLâ€™de kilitler
Ä°statistikler
Transactionlar
Ä°leri DÃ¼zey BakÄ±m iÅŸlemleri

Table Partitioning
Copy komutu

EÄŸitimler hafta 
iÃ§i  09:30-10:30 / 11:00-12:00 
ve   14:00-15:00 / 15:30-16:30 
saatleri arasÄ±nda gerÃ§ekleÅŸecektir. bÃ¼ÄŸÃ¼n 12:30 - 14:00 

09:30-10:30 / 11:00-12:00 
13:30-14:30 / 15:00-16:00 


1. Postgresql GiriÅŸ


-----------------------------------------------------------------------------
-- ğŸŒ https://www.postgresql.org/
-- â­•ï¸ GiriÅŸ
/* 

âœ¨ PostgreSQL: The World's Most Advanced Open Source Relational Database âœ¨
âœ¨ PostgreSQL: DÃ¼nyanÄ±n En GeliÅŸmiÅŸ AÃ§Ä±k Kaynak Ä°liÅŸkisel VeritabanÄ± âœ¨

New to PostgreSQL?

PostgreSQL, 35 yÄ±lÄ± aÅŸkÄ±n sÃ¼redir aktif olarak geliÅŸtirilen, gÃ¼venilirliÄŸi, sorunsuz Ã§alÄ±ÅŸmasÄ± ve yÃ¼ksek performansÄ±yla bilinen gÃ¼Ã§lÃ¼ ve aÃ§Ä±k kaynaklÄ± bir nesne-iliÅŸkisel veritabanÄ± sistemidir.

-----------------------------------------------------------------------------
-- ğŸŒ https://www.postgresql.org/#Latest%20Releases
-- â­•ï¸ Latest Releases
-- PostgresSQL SÃ¼rÃ¼mleri


The PostgreSQL Global Development Group has released an update to all supported versions of PostgreSQL, including 17.4, 16.8, 15.12, 14.17, and 13.20.



-- ğŸŒ https://www.postgresql.org/support/versioning/
-- â­•ï¸ Postgres sÃ¼rÃ¼mleri

-- â­•ï¸ The PostgreSQL Global Development Group ( PostgreSQL KÃ¼resel GeliÅŸtirme Grubu )
ğŸ”¸ Postgres yÄ±lda bir kez major (genelde eylÃ¼l ayÄ± iÃ§inde),kalan aylarda sene iÃ§inde 3 ayda bir 
minor sÃ¼rÃ¼m yayÄ±nlamaktadÄ±r. Ã–nemli bir gÃ¼venlik aÃ§Ä±ÄŸÄ± olduÄŸunda ek minor sÃ¼rÃ¼mler yayÄ±nlanabiliyor.

ğŸ”¸Major sÃ¼rÃ¼m, Yeni Ã¶zellikler ve perfomans kazanÄ±mlarÄ±
ğŸ”¸Minor sÃ¼rÃ¼m, GÃ¼nvenlik aÃ§Ä±klarÄ±nÄ± kapatmak iÃ§in





-- â­•ï¸ releases 
Site Ã¼zerinde bulunan tabloda postgres versiyonlarÄ±n EOL (end of life) tarihlerine ulaÅŸÄ±labilir.

Version	Current minor	Supported	First Release		Final Release
17		17.4			Yes			September 26, 2024	November 8, 2029
16		16.8			Yes			September 14, 2023	November 9, 2028
15		15.12			Yes			October 13, 2022	November 11, 2027
14		14.17			Yes			September 30, 2021	November 12, 2026
13		13.20			Yes			September 24, 2020	November 13, 2025
12		12.22			No			October 3, 2019		November 21, 2024


-- ğŸŒ https://www.postgresql.org/list/
-- â­•ï¸ maill grublarÄ±
ğŸ”¸Ãœzerinden community ile gerÃ§ekleÅŸen mail arÅŸivlerine ulaÅŸÄ±labilir, 
ğŸ”¸GeÃ§miÅŸte sorulan Ã¼zerinden karÅŸÄ±laÅŸtÄ±ÄŸÄ±mÄ±z hatalar aranababilir. 
ğŸ”¸Kendimizde community mail grubuna yardÄ±mcÄ± olmalarÄ± iÃ§in soru aÃ§abiliriz.
ğŸ”¸Ä°stediÄŸimiz mail gruplarÄ±na abone olarak mailleÅŸlemeleri takip edebilirsiniz.



-----------------------------------------------------------------------------
-- ğŸŒ https://www.postgresql.org/docs/current/index.html
-- â­•ï¸ Postgresql Offical Doc

ğŸ”¸Postgres geliÅŸtirici grubu tarafÄ±ndan dÃ¼zenlenmektedir
ğŸ”¸Postgres kullanÄ±mÄ±na yÃ¶nelik ilk kaynak olarak bakÄ±lmalÄ±dÄ±r.



-- ğŸŒ https://wiki.postgresql.org/wiki/Main_Page
-- â­•ï¸ Postgresql Wiki

ğŸ”¸ how-to , ipucu ve tricklerin toplandÄ±ÄŸÄ± bir web sayfasÄ±dÄ±r.
ğŸ”¸ Postgresql iligi bir Ã§ok baÅŸlÄ±k toparlanmÄ±ÅŸtÄ±r 
ğŸ”¸ Postgres perfomance iyileÅŸtirmesi iÃ§in yazÄ±lar
ğŸ”¸ Postgres ilgili sunumlar
vb.. yararlÄ± bilgiler yer alÄ±r.


-- ğŸŒ https://www.postgresql.org/docs/current/history.html
-- â­•ï¸ Postgresql GeliÅŸimi
ğŸ”¸ DÃ¼nyanÄ±n en geliÅŸmiÅŸ aÃ§Ä±k kaynak projesi 
ğŸ”¸ Ã–lÃ§ekelenebilirlik ve Ã–zelleÅŸtirme iÃ§in tasarlandÄ±
ğŸ”¸ ANSI/ISO uyumlu SQL desteÄŸi  
ğŸ”¸ 30 yÄ±lÄ± aÅŸkÄ±n sÃ¼redir aktif olarak geliÅŸtirilmekte
ğŸ”¸ Postgres Ãœniversite ilk adÄ±mÄ± (1986-1993) ,  Abd kamu kurumlarÄ± tarafÄ±ndan sponsor
ğŸ”¸ Postgres95 (1994-1995)      , Orjinal kod %25 oranÄ±n azaltÄ±ldÄ± , %30-%50 perfomans
ğŸ”¸ PostgreSQL (1996-current)   , PostQUEL sorgu dili -> SQL dili dÃ¶nÃ¼ÅŸÃ¼mÃ¼ gerkÃ§ekleÅŸti. 

-- ğŸŒ https://www.postgresql.org/about/
-- â­•ï¸ Postgresql HakkÄ±nda
ğŸ”¸ YaygÄ±n iÅŸletim sistemleri Ã¼zerinde Ã§alÄ±ÅŸabilmektedir. 
ğŸ’¥ En iyi perfomans linux iÅŸletim sistemleri Ã¼zerinde gÃ¶stermektedir.

- Postgresql Sahip olduÄŸu Ã–zellikler

ğŸ”¶ Data Types (geniÅŸ veri tipi yelpazesi , Ã¶zelleÅŸtirebilir veri tipi )
ğŸ”¸ Primitives: Integer, Numeric, String, Boolean
ğŸ”¸ Structured: Date/Time, Array, Range / Multirange, UUID
ğŸ”¸ Document: JSON/JSONB, XML, Key-value (Hstore)
ğŸ”¸ Geometry: Point, Line, Circle, Polygon
ğŸ”¸ Customizations: Composite, Custom Types 

ğŸ”¶ Data Integrity (veri tutarlÄ±lÄ±ÄŸÄ±)
ğŸ”¸ UNIQUE, NOT NULL
ğŸ”¸ Primary Keys
ğŸ”¸ Foreign Keys
ğŸ”¸ Exclusion Constraints
ğŸ”¸ Explicit Locks, Advisory Locks
ğŸ”¶ Concurrency, Performance (paralel sorgu , perfomans)
ğŸ”¸ Indexing: B-tree, Multicolumn, Expressions, Partial
ğŸ”¸ Advanced Indexing: GiST, SP-Gist, KNN Gist, GIN, BRIN, Covering indexes, Bloom filters
ğŸ”¸ Sophisticated query planner / optimizer, index-only scans, multicolumn statistics
ğŸ”¸ Transactions, Nested Transactions (via savepoints)
ğŸ”¶ Multi-Version concurrency Control (MVCC)  (Birden fazla kiÅŸinin Ã§alÄ±ÅŸmasÄ±)
ğŸ”¸ Parallelization of read queries and building B-tree indexes
ğŸ”¸ Table partitioning
ğŸ”¸ All transaction isolation levels defined in the SQL standard, including Serializable
ğŸ”¸ Just-in-time (JIT) compilation of expressions
ğŸ”¶ Reliability, Disaster Recovery (dayanaklÄ±lÄ±k ve felaketlerden sorunsuz dÃ¶nÃ¼ÅŸ)
ğŸ”¸ Write-ahead Logging (WAL)
ğŸ”¸ Replication: Asynchronous, Synchronous, Logical
ğŸ”¸ Point-in-time-recovery (PITR), active standbys
ğŸ”¸ Tablespaces

ğŸ”¶ Security (gÃ¼venlik)
ğŸ”¸ Authentication: GSSAPI, SSPI, LDAP, SCRAM-SHA-256, Certificate, and more
ğŸ”¸ Robust access-control system
ğŸ”¸ Column and row-level security
ğŸ”¸ Multi-factor authentication with certificates and an additional method


ğŸ”¶ Extensibility (GeniÅŸletilebilirlik )
ğŸ”¸ Stored functions and procedures
ğŸ”¸ Procedural Languages: PL/pgSQL, Perl, Python, and Tcl. There are other languages available ğŸ”¸through extensions, e.g. Java, JavaScript (V8), R, Lua, and Rust
ğŸ”¸ SQL/JSON constructors, query functions, path expressions, and JSON_TABLE
ğŸ”¸ Foreign data wrappers: connect to other databases or streams with a standard SQL interface

dblink, sorgu yollama iÃ§in 

postgres_fdw  tabloyu mapliyorsunuz
orcale_fdw    join perfomansÄ±
ğŸ”¸ Customizable storage interface for tables
ğŸ”¸ Many extensions that provide additional functionality, including PostGIS

ğŸ”¶ Internationalisation, Text Search ( Dil desteÄŸi ve geliÅŸmiÅŸ metin arama )
ğŸ”¸ Support for international character sets, e.g. through ICU collations
ğŸ”¸ Case-insensitive and accent-insensitive collations
ğŸ”¸ Full-text search


Eklenti Ã§eÅŸitliliÄŸi postgres Ã¶nemli Ã¶zelliklerinden biridir.

-- ğŸŒ https://github.com/pgvector/pgvector
-- â­•ï¸ pg_vector
GÃ¼nÃ¼mÃ¼zde llm (large language models) ve RAG sistemleri iÃ§in vectordb olarak postgres kullanmamÄ±za olanak saÄŸlar.

Postgres, Vector arama , vector indeks Ã¶zelliÄŸi kazandÄ±rÄ±yor. 


-- ğŸŒ https://www.timescale.com/
-- â­•ï¸ timescaledb

IOT , AI, crypto gibi verilerin daha perfomanslÄ± yÃ¶netilmesi saÄŸlÄ±yor.
Ã–rn, Zabbix monitoring aracÄ± verileri postgres timescaledb Ã¼zerinde tutmaktadÄ±r.

-- ğŸŒ https://postgis.net/
-- â­•ï¸ postgis
Mekansal verileri iÅŸlenmesi ve analizinde kullanÄ±lan Ã§ok yaygÄ±n bir eklentisidir.

-- ğŸŒ https://gist.github.com/joelonsql/e5aa27f8cc9bd22b8999b7de8aee9d47
-- â­•ï¸ github adresin binlerce eklenti 


1ï¸âƒ£ Postgres CORE , eÄŸitimde iÅŸleyeceÄŸimiz

Postgres Ã§ok sevilen ve community geniÅŸ bir kitle olduÄŸu iÃ§in Ã§ok fazla Ã¶zelleÅŸtirmeler sahip.

2ï¸âƒ£ Postgres CORE + eklentiler ile yardÄ±mcÄ± yada yeni Ã¶zellikler kazanÄ±yor.
3ï¸âƒ£ Postgres CORE forklanarak ve kaynak kodlarÄ±n deÄŸiÅŸtirilmesi geliÅŸtirilen Ã¼rÃ¼nler 
4ï¸âƒ£ PostgreSQL uyumlu Ã§alÄ±ÅŸan Ã¶zÃ¼nde postgres core engine bulunmayan Ã¼rÃ¼nler

3 ve 4 adÄ±mlarda postgres coredan farklÄ± Ã¼rÃ¼nlerdir bunlarÄ±n gÃ¼ncellenmesinde  gÃ¼venlik aÃ§Ä±klarÄ±ndan PostgreSQL Global Development Group sorumlu deÄŸildir. ÃœrÃ¼nÃ¼nÃ¼ baÅŸka yapÄ±lar geliÅŸtirmektedir. 

3ï¸âƒ£
-- ğŸŒ https://www.enterprisedb.com/docs/epas/latest/
-- â­•ï¸ EDB Postgres Advanced Server (EPAS)  ( Oracle compatibility)
Postgres core, Ã¼zerine perfomans iyileÅŸtirmeleri ve oracle uyumluluÄŸa sahip postgres.

-- ğŸŒ https://www.yugabyte.com/
-- â­•ï¸ yugabytedb  (Distributed PostgreSQL for Modern Apps) 
postgres 15 verisyonu, global postgres 17 saÄŸladÄ±ÄŸÄ± halde

master standby
distrubeted ,   yugabytede master master, 

4ï¸âƒ£
-- ğŸŒ https://www.cockroachlabs.com/docs/stable/postgresql-compatibility
-- â­•ï¸ cockroachdb  sql-disbureted 


-- https://noncodersuccess.medium.com/is-postgresql-taking-over-the-database-world-e3a0680230a9
Postgres, sektÃ¶r ihtiyaÃ§larÄ±na yÃ¶nelik nosql, Ä±ot , mekansal , analtilik sorgular  Ã§Ã¶zÃ¼mler sunuyor.


-- ğŸŒ https://www.postgresql.org/docs/current/glossary.html
-- â­•ï¸ Glossary - Terimler SÃ¶zlÃ¼ÄŸÃ¼ 

PostgreSQL ve iliÅŸkilel veritabanlarÄ±nda genel tanÄ±mlamalar bulunmakta. DÃ¶kÃ¼man iÃ§ersinde anlamadÄ±ÄŸÄ±m bir tanÄ±m olduÄŸunda buraya bakabiliriz.

Ã–rn: database cluster ? cluster?

A collection of databases and global SQL objects, and their common static and dynamic metadata. Sometimes referred to as a cluster. A database cluster is created using the initdb program.

In PostgreSQL, the term cluster is also sometimes used to refer to an instance. (Don't confuse this term with the SQL command CLUSTER.)

-- â­•ï¸ Postgres diÄŸer veritabanlarÄ±na gÃ¶re farklÄ± tanÄ±mlar 

YaygÄ±n KullanÄ±m 				| PostgreSQL KarÅŸÄ±lÄ±ÄŸÄ±
==============================	|======================================
Table or Index 					| Relation 
Row  (satÄ±r) 					| Tuple
Column  (kolon) 				| Attribute 
Schema  (ÅŸema) 					| Namespace
Data Block  (diskte bloklara)	| Page (veri bloÄŸu diskte olduÄŸunda)
Page  (ramdeki bloklara) 	   	| Buffer (veri bloÄŸu bellekte olduÄŸunda)
Data Dizini 					| Cluster


-- ğŸŒ https://www.postgresql.org/docs/current/limits.html
-- â­•ï¸ Appendix K. PostgreSQL Limits

ğŸ”¸Database size	unlimited (diskin limitine baÄŸlÄ±)
ğŸ”¸number of databases , 4,294,950,911
ğŸ”¸relation size 32 TB  , bir tablonun yada indexin maksimum boyutu 
ğŸ”¸rows per table , 4,294,967,295
ğŸ”¸columns per table , 1600 
ğŸ”¸field size 1 GB , tablomuzdaki bir deÄŸerin ulaÅŸabileceÄŸi maximum boyut
ğŸ”¸indexes per table , unlimited
ğŸ”¸columns per index , 32 
ğŸ”¸identifier length  63bytes , obje isimlerin (tablo,kolon vb .. ) alabileceÄŸi uzunluk fazlasÄ± kesiliyor

*/
select '2' as abcdefabcdefabcdefabcdefabcdefabcdefabcdefabcdefabcdefabcdefabcdefabcdefabcdef
enpterisedb pgee fujitse,  tde , daha gÃ¼venlik sitemleri ekleniyor. 


-- kurulum 

https://www.postgresql.org/download/linux/ubuntu/



-- ubuntu sabit ip 

vi /etc/netplan/50-cloud-init.yaml

network:
  version: 2
  ethernets:
    ens33:
      dhcp4: false
      addresses:
        - 10.10.11.141/24 --> sabit ip adresi

-- 11:30 - 12:30  
Exa ram durumlarÄ±n,  630gb ram var .

/*----------------------------------------------------
ğŸ”´ POSTGRES KURULUMU 
------------------------------------------------------
â­•ï¸ 1ï¸âƒ£ Binary Files
--------------------
ğŸŒ https://www.postgresql.org/download/ Ã¼zerinde iÅŸletim sistemize uygun postgres binary dosyalarÄ±nÄ± kurulumu gerÃ§ekleÅŸtirilir.


/*

# Import the repository signing key:
sudo apt install curl ca-certificates
sudo install -d /usr/share/postgresql-common/pgdg
sudo curl -o /usr/share/postgresql-common/pgdg/apt.postgresql.org.asc --fail https://www.postgresql.org/media/keys/ACCC4CF8.asc

# Create the repository configuration file:
. /etc/os-release
sudo sh -c "echo 'deb [signed-by=/usr/share/postgresql-common/pgdg/apt.postgresql.org.asc] https://apt.postgresql.org/pub/repos/apt $VERSION_CODENAME-pgdg main' > /etc/apt/sources.list.d/pgdg.list"

# Update the package lists:
sudo apt update

# Install the latest version of PostgreSQL:
# If you want a specific version, use 'postgresql-17' or similar instead of 'postgresql'
sudo apt -y install postgresql

*/


Bir sunucuda postgres binary kurulumu ile  

ğŸŒ https://www.postgresql.org/docs/current/reference-client.html


araÃ§ setlerine sahip oluyoruz. Postgres serverÄ±n kurulum, yÃ¶netim ve bakÄ±m vb ... iÅŸlemlerini bu araÃ§lar ile gerÃ§ekleÅŸtiriyoruz.

ğŸ” find / -iname pg_ctl 
linux sunucu Ã¼zerinde bulunan postgres araÃ§ setlerini tespit edilebilir.


-----
ğŸŒ https://www.postgresql.org/docs/current/glossary.html#GLOSSARY-DB-CLUSTER
ğŸŒ https://www.postgresql.org/docs/current/creating-cluster.html
â­•ï¸ 2ï¸âƒ£ A database cluster / cluster (Postgres Server)
--------------------

ğŸ”¸ Herhangi bir iÅŸlem yapmadan Ã¶nce, diskte bir veritabanÄ± saklama alanÄ± oluÅŸturmanÄ±z gerekir. Buna DATABASE CLUSTER (cluster) denir. (SQL standardÄ±nda bu yapÄ± â€œcatalog clusterâ€ olarak adlandÄ±rÄ±lÄ±r.)

ğŸ”¸Database Cluster, Ã§alÄ±ÅŸan bir database server yÃ¶nettiÄŸi birden fazla veritabanÄ±ndan oluÅŸan bir yapÄ±dÄ±r.

ğŸ”¸Ä°lk kurulumdan sonra, bu kÃ¼meye postgres adÄ±nda varsayÄ±lan bir veritabanÄ± otomatik olarak eklenir. Bu veritabanÄ± genellikle sistem araÃ§larÄ±, kullanÄ±cÄ±lar ve Ã¼Ã§Ã¼ncÃ¼ parti uygulamalar tarafÄ±ndan kullanÄ±lÄ±r. Sunucunun Ã§alÄ±ÅŸmasÄ± iÃ§in bu veritabanÄ± zorunlu deÄŸildir, ancak birÃ§ok dÄ±ÅŸ araÃ§ bu veritabanÄ±nÄ±n var olduÄŸunu varsayar.

âš ï¸ VarsayÄ±lan olarak eriÅŸilen postgres veritabanÄ±nÄ±n geliÅŸtirme iÃ§in kullanÄ±lmamasÄ± Ã¶nerilir. 


ğŸ”¸ AyrÄ±ca, kurulum sÄ±rasÄ±nda template1 ve template0 adÄ±nda iki veritabanÄ± daha oluÅŸturulur. Bu veritabanlarÄ±, ileride oluÅŸturulacak yeni veritabanlarÄ±na ÅŸablon olarak kullanÄ±lÄ±r.

âœ¨ Ã–rn. create database profelis; komutu ile  bu template veritabanlarÄ±nÄ± klonlamÄ±ÅŸ oluruz. 


ğŸ”¸ Dosya sistemi aÃ§Ä±sÄ±ndan bakÄ±ldÄ±ÄŸÄ±nda, bir DATABASE CLUSTER, verilerin saklandÄ±ÄŸÄ± dizinden oluÅŸur. "data directory" olarak postgres yÃ¶netim komutlarÄ±nda bu dizinin konumu belirtilir. 

pg_ctl -D data directory

ğŸ”¸ "Database CLuster" terimini postgres dÃ¶kÃ¼manÄ± iÃ§ersinde gÃ¶rdÃ¼ÄŸÃ¼mÃ¼zde yekpare postgres sunucusunu aklÄ±mÄ±za gelmeli.  

âœ¨ Ã–rn. pg_basebackup is used to take a base backup of a running PostgreSQL database cluster.
pg_basebackup aracÄ± ile yedek aldÄ±ÄŸÄ±mÄ±zda database cluster kopyasÄ±nÄ± almÄ±ÅŸ oluruz. 

----------------------------------------------------------------
ğŸŒ https://www.postgresql.org/docs/current/app-initdb.html
initdb â€” create a new PostgreSQL database cluster
initdb â€” Yeni Bir PostgreSQL veritabanÄ± kÃ¼mesi oluÅŸturma
----------------------------------------------------------------

ğŸ”¸A database cluster is created using the "initdb" program.

VeritabanÄ± kÃ¼mesi (Cluster), PostgreSQL sunucusunun yÃ¶nettiÄŸi veritabanlarÄ±yla ilgili tÃ¼m yapÄ±larÄ±n, kullanÄ±cÄ±larÄ±n ve yÃ¶netimsel ayarlarÄ±n saklandÄ±ÄŸÄ± dosyalarÄ±n tamamÄ±nÄ± ifade eder.


ğŸŒ https://www.postgresql.org/docs/current/app-initdb.html
ğŸ” find / -iname pg_ctl 
â„¹ï¸ /usr/lib/postgresql/17/bin/initdb --help komut satÄ±rÄ±nda yada 
https://www.postgresql.org/docs/current/app-initdb.html linki Ã¼zerinden komutun aldÄ±ÄŸÄ± parametreler incelenebilir.

/*
ğŸ”¸ -A authmethod

initdb yÃ¼rÃ¼tÃ¼ldÃ¼ÄŸÃ¼nde pg_hba.conf iÃ§erisindeki authmethod ayarlanmasÄ±nÄ± saÄŸlÄ±yor. trust,md5,scram-sha-256 vb..


ğŸ”¸ -D directory , --pgdata=directory  ğŸ’¥ğŸ’¥ğŸ’¥
Database cluster kurulacaÄŸÄ± konumu belirtir.
Sistemde PGDATA deÄŸiÅŸkeni ile environment variable tanÄ±mlanabilir. 

ğŸ”¸ -E encoding , --encoding=encoding 

Selects the encoding of the template databases. This will also be the default encoding of any database you create later, unless you override it then. 

CREATE DATABASE ... komutuyle template database klonlanmaktadÄ±r. Bu template database CHARACTER ENCODING dilini bu parametre ile tanÄ±mlanabilir. VarsayÄ±lan sistemin encoding ile aynÄ±dÄ±r.

Ã¶rn: UTF-8

â„¹ï¸ Daha sonra, ÅŸablon veritabanÄ± (template database) ve veritabanÄ± oluÅŸturma (CREATE DATABASE) adÄ±mÄ±nda karakter kodlamasÄ± (encoding) deÄŸiÅŸtirilebilir.


ğŸ”¸ -k , --data-checksums ğŸ’¥ğŸ’¥ğŸ’¥â˜¢ï¸â˜¢ï¸â˜¢ï¸
ğŸŒ https://www.postgresql.org/docs/current/checksums.html

By default, data pages are not protected by checksums, but this can optionally be enabled for a cluster. When enabled, each data page includes a checksum that is updated when the page is written and verified each time the page is read. Only data pages are protected by checksums; internal data structures and temporary files are not.

PostgreSQL'de varsayÄ±lan olarak veri sayfalarÄ± checksum ile korunmaz. Ancak initdb --data-checksums seÃ§eneÄŸiyle bu Ã¶zellik etkinleÅŸtirilebilir. EtkinleÅŸtirildiÄŸinde, her veri sayfasÄ±na bir checksum eklenir; sayfa yazÄ±ldÄ±ÄŸÄ±nda gÃ¼ncellenir, okunduÄŸunda doÄŸrulanÄ±r. Bu Ã¶zellik yalnÄ±zca veri sayfalarÄ±nÄ± kapsar; geÃ§ici dosyalar ve dahili yapÄ±lar korunmaz. Veri bozulmalarÄ±na karÅŸÄ± haberdar olmak iÃ§in aÃ§Ä±k tutulmasÄ± Ã¶nerilir.

*/*/

select * from pg_stat_database ; --> istatistik tablosunda ortaya Ã§Ä±kan checksum failure takip edilebilir.

/*
ğŸ”¸ --locale=locale ğŸ’¥ğŸ’¥
C.UTF-8 , tr_TR.UTF-8  , en_EN.UTF-8 vb tanÄ±mlamalar ile lokal dilin bÃ¼yÃ¼k/kÃ¼Ã§Ã¼k harf eÅŸlemesi, sÄ±ralama, alfabetik dÃ¼zen vb.. uyum saÄŸlar.

C.UTF-8 multilanguage bir uygulama iÃ§in kullanÄ±m
tr_TR.UTF-8,en_EN.UTF-8 yerelleÅŸtirme gibi durumlarda seÃ§ilebilir.

ğŸ”¸ -W , --pwprompt 
initdb komutu Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda baÅŸlangÄ±Ã§ta oluÅŸturulan sÃ¼per kullanÄ±cÄ± iÃ§in ÅŸifre girmenizi saÄŸlar.

initdb -D /pgdata -W 

ğŸ”¸ -X,  directory ğŸ’¥ğŸ’¥
--waldir=directory 
This option specifies the directory where the write-ahead log should be stored.

Postgres sunucusunda Ã¼retilen wal (Write ahead log ) dosyalarÄ±n tutulacaÄŸÄ± dizini tanÄ±mlayan parametredir. VarsayÄ±lan PGDATA iÃ§erisinde pg_wal dizini altÄ±ndadÄ±r.

â„¹ï¸ pg_wal dizinin PGDATA dizininden farklÄ± mountpoint tutulmasÄ± Ã¶nerilir.
â„¹ï¸ pg_wal dizini symbolik kullanÄ±larak oluÅŸturulmaktadÄ±r. Sonradan veritabanÄ± durdurulmasÄ± ile konumu deÄŸiÅŸtirebilir.

ğŸ”¸ -c name=value , --set name=value  ğŸ’¥

postgresql.conf dosyasÄ±ndaki bazÄ± yapÄ±landÄ±rma parametrelerinin kurulum sÄ±rasÄ±nda belirlenmesine olanak tanÄ±r.

-c logging_collector=on  -c  log_directory=/data/pg_log -c port=5433

ğŸ”¸ -V , --version

Basit Kurulum AdÄ±mÄ±

/pgdata --direk datadizin kullnaÄ±lmalÄ±


/pgdata/pg17

/pgdata/pg18


-- Root kullanÄ±cÄ±sÄ±nda dizin tanÄ±mÄ± gerÃ§ekleÅŸtirme ve yetkilendirme
mkdir /data/simple_data
chown postgres:postgres -R /data/simple_data

*/
-- postgres kullanÄ±cÄ±snda initdb komutunu yÃ¼rÃ¼tÃ¼lmesi

/usr/lib/postgresql/17/bin/initdb -D  /data/simple_data  -k  


-- Komutunu yÃ¼rÃ¼tÃ¼ldÃ¼ÄŸÃ¼nde gerÃ§ekleÅŸen iÅŸlemlerin dÃ¶kÃ¼mÃ¼.

The files belonging to this database system will be owned by user "postgres".
This user must also own the server process.

The database cluster will be initialized with locale "en_US.UTF-8".
The default database encoding has accordingly been set to "UTF8".
The default text search configuration will be set to "english".

Data page checksums are enabled.

fixing permissions on existing directory /data/simple_data ... ok
creating subdirectories ... ok
selecting dynamic shared memory implementation ... posix
selecting default "max_connections" ... 100
selecting default "shared_buffers" ... 128MB
selecting default time zone ... Europe/Istanbul
creating configuration files ... ok
running bootstrap script ... ok
performing post-bootstrap initialization ... ok
syncing data to disk ... ok

initdb: warning: enabling "trust" authentication for local connections
initdb: hint: You can change this by editing pg_hba.conf or using the option -A, or --auth-local and --auth-host, the next time you run initdb.

Success. You can now start the database server using:

    /usr/lib/postgresql/17/bin/pg_ctl -D /data/simple_data -l logfile start


/*--------------------------------------------------------------------
ğŸ”´ Database File Layout
ğŸŒ https://www.postgresql.org/docs/current/storage-file-layout.html
----------------------------------------------------------------------

ğŸ”¶ /data/simple_data DATABASE CLUSTER dizini altÄ±ndaki oluÅŸan dosyalar

base	      pg_ident.conf  pg_serial	    pg_tblspc	postgresql.auto.conf
global	      pg_logical     pg_snapshots  pg_twophase	postgresql.conf
pg_commit_ts  pg_multixact   pg_stat	    PG_VERSION
pg_dynshmem   pg_notify      pg_stat_tmp   pg_wal
pg_hba.conf   pg_replslot    pg_subtrans   pg_xact

ğŸ”¶ Bir postgres dba etkileÅŸimde bulanacaÄŸÄ± dosyalar 
ğŸ”¸postgresql.conf  , server yapÄ±landÄ±rma  ğŸ’¥ğŸ’¥ğŸ’¥
ğŸ”¸pg_hba.conf      , server firewall yapÄ±landÄ±rma ğŸ’¥ğŸ’¥ğŸ’¥
ğŸ”¸postgresql.auto.conf , server yapÄ±landÄ±rma , sql istemci ile verilen komutlar  ğŸ’¥ğŸ’¥ğŸ’¥
ğŸ”¸pg_wal  , wal ve archive durumunu ilerlemesi hakkÄ±nda bilgi iÃ§in. ğŸ’¥ğŸ’¥ğŸ’¥
ğŸ”¸base    , veritabanÄ±  bÃ¼yÃ¼klÃ¼ÄŸÃ¼ bilgisi  ğŸ’¥ğŸ’¥
ğŸ”¸PG_VERSION , database cluster hangi versiyona ait kurulduÄŸu bilgisi. ğŸ’¥

Data directory, Postgres serverÄ± baÅŸlatÄ±ldÄ±ÄŸÄ±nda gÃ¶rebileceÄŸimiz dosyalar.

ğŸ”¸postmaster.pid , Postgres process, hangi pid , baÅŸlama zamanÄ±, port vb .. bilgileri bulunur. Dizindeki postgres veritabanÄ±n Ã§alÄ±ÅŸmadÄ±ÄŸÄ±nÄ± bu dosya ile anlayabiliriz.ğŸ’¥ğŸ’¥ğŸ’¥

ğŸ”¸standby.signal , sunucu recovery mod durumunda tutar , yazmalarÄ± kabul etmez.ğŸ’¥ğŸ’¥ğŸ’¥

select * from pg_database;


/usr/lib/postgresql/17/bin/pg_ctl start -D /data/simple_data 

â˜¢ï¸ PostgreSQL BaÅŸlatÄ±lamÄ±yor mu? postmaster.pid DosyasÄ±na Dikkat!
BazÄ± durumlarda, Ã¶rneÄŸin sunucu beklenmedik ÅŸekilde kapanÄ±rsa (crash), PostgreSQLâ€™in Ã§alÄ±ÅŸma durumu bilgilerini iÃ§eren postmaster.pid dosyasÄ± veri dizininde (data directory) kalabilir.
ğŸš« Bu dosya dururken PostgreSQL tekrar baÅŸlatÄ±lamaz. Ã‡Ã¼nkÃ¼ sistem hala baÅŸka bir postmaster sÃ¼recinin Ã§alÄ±ÅŸtÄ±yor diye yorumlar. 
âš ï¸ Dikkat: Bu iÅŸlemi yapmadan Ã¶nce PostgreSQLâ€™in gerÃ§ekten Ã§alÄ±ÅŸmadÄ±ÄŸÄ±ndan emin olun. Aksi takdirde veri kaybÄ± riski doÄŸabilir.
*/

1.Binary kurulumu (postgresql.org/downloads) 
2.Database cluster dizini kurulumu (initdb)
3.Database Server BaÅŸlatma (pg_ctl)

/*----------------------------------------------------------
ğŸŒ https://www.postgresql.org/docs/current/app-pg-ctl.html
ğŸ”´ pg_ctl â€” initialize, start, stop, or control a PostgreSQL server
Bir Database CLusterÄ±nÄ± BaÅŸlatma
----------------------------------------------------------

ğŸ”¶ -D ile hangi database clusterÄ±nÄ± yÃ¶neteceÄŸini belirtiyioruz.

/usr/lib/postgresql/17/bin/pg_ctl start -D /data/simple_data 


  76  systemctl stop postgresql@17-main.service 
   77  systemctl disable  postgresql@17-main.service 
   78  systemctl disable  postgresql.service
   79  systemctl stop   postgresql.service


/usr/lib/postgresql/17/bin/pg_ctl start -D /data/simple_data 
waiting for server to start....2025-05-13 09:20:45.152 UTC [6078] LOG:  starting PostgreSQL 17.5 (Ubuntu 17.5-1.pgdg24.04+1) on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0, 64-bit
2025-05-13 09:20:45.152 UTC [6078] LOG:  listening on IPv4 address "127.0.0.1", port 5432
2025-05-13 09:20:45.153 UTC [6078] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
2025-05-13 09:20:45.160 UTC [6081] LOG:  database system was shut down at 2025-05-13 09:04:23 UTC
2025-05-13 09:20:45.177 UTC [6078] LOG:  database system is ready to accept connections
 done
server started


/usr/lib/postgresql/17/bin/pg_ctl start -D /data/simple_data 
pg_ctl: another server might be running; trying to start server anyway
waiting for server to start....2025-05-13 09:21:18.275 UTC [6096] FATAL:  lock file "postmaster.pid" already exists
2025-05-13 09:21:18.275 UTC [6096] HINT:  Is another postmaster (PID 6078) running in data directory "/data/simple_data"?
 stopped waiting
pg_ctl: could not start server
Examine the log output.

-- Åimdiye kadar Ã¶ÄŸrendiÄŸimiz bilgileri nasÄ±l kullanabiliriz .

â“â“â“ Senaryo: KÃ¶rlemesine bir sunucu verildi size burada postgres Ã§alÄ±ÅŸtÄ±ÄŸÄ± belirtildi. Postgres hangi dizinde kurulmuÅŸ ve Ã§alÄ±ÅŸÄ±yor ? NasÄ±l anlayacaÄŸÄ±z.
â“â“â“

âš ï¸ Bir Sunucuda Ã‡alÄ±ÅŸan PostgreSQL ServerlarÄ±nÄ± (Instance) Tespit Etme

Bir sunucuda kaÃ§ adet PostgreSQL veritabanÄ± kÃ¼mesi (cluster) Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± gÃ¶rmek istiyorsak, bunun en pratik yollarÄ±ndan biri postmaster.pid dosyalarÄ±nÄ± aramaktÄ±r.


ğŸ” find / -iname postmaster.pid 2>/dev/null

/pgdata/postmaster.pid
/data/simple_data/postmaster.pid

Bu komut sayesinde hangi konumlarda pg_ctl start komutu ile baÅŸlatÄ±lmÄ±ÅŸ veritabanÄ± kÃ¼meleri olduÄŸunu Ã¶ÄŸrenebiliriz.

â“â“â“ Senaryo: Sunucu Crash oldu postgres baÅŸlamÄ±yor. Bizede xxx serverÄ±nda postgres baÅŸlatÄ±lmasÄ± gerektiÄŸi iletildi.
â“â“â“

ğŸ” find / -iname pg_wal 2>/dev/null

pg_ctl start -D data_directory

*/* 

-- Ã¶zet:

1.Binary kurulumu (postgresql.org/downloads) 
2.Database cluster, dizini kurulumu (initdb)
3.Database Server BaÅŸlatma (pg_ctl)
/*
------------------------------
ğŸ”¶ pg_ctl --help   ğŸ’¥ğŸ’¥ğŸ’¥

pg_ctl, PostgreSQL veritabanÄ± sunucusunu baÅŸlatmak, durdurmak, yeniden baÅŸlatmak, durumunu gÃ¶rmek gibi iÅŸlemler iÃ§in kullanÄ±lan temel yÃ¶netim aracÄ±dÄ±r.

ğŸ”¸ pg_ctl init[db]   [-D DATADIR] [-s] [-o OPTIONS]
initdb komutunu yÃ¼rÃ¼tmek iÃ§in. 

data_dizinini baÅŸlatmak iÃ§in.

pg_ctl start -D /data_dizin


ğŸ”¸pg_ctl stop       [-D DATADIR] [-m SHUTDOWN-MODE] [-W] [-t SECS] [-s]
ğŸ”¸pg_ctl restart    [-D DATADIR] [-m SHUTDOWN-MODE] [-W] [-t SECS] [-s]
                    [-o OPTIONS] [-c]

Data_dizinin aktif Ã§alÄ±ÅŸan postgres durdurmak / restart etmek iÃ§in.

pg_ctl stop -D /data_dizin
pg_ctl stop -mi -D /data_dizin

Options for stop or restart:
  -m, --mode=MODE        MODE can be "smart", "fast", or "immediate"
Shutdown modes are:
  smart       quit after all clients have disconnected --
  fast        quit directly, with proper shutdown (default) -- oracle immediatte
âš ï¸immediate   quit without complete shutdown; will lead to recovery on restart -- oracle abort

pg_ctl stop -mf -D /data_dizin


PostgreSQL, immediate modu ile kapatÄ±ldÄ±ÄŸÄ±nda veritabanÄ± dÃ¼zgÃ¼n bir ÅŸekilde kapanmaz. Bu nedenle yeniden baÅŸlatÄ±ldÄ±ÄŸÄ±nda, en son checkpoint noktasÄ±ndan itibaren WAL kayÄ±tlarÄ±nÄ± (write-ahead log) okuyarak veri bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ saÄŸlar.

Sunucu tamamen aÃ§Ä±ldÄ±ÄŸÄ±nda log dosyasÄ±nda ÅŸu satÄ±rÄ± gÃ¶rÃ¼rsÃ¼nÃ¼z:
Database system is ready to accept connections.

ğŸ”¸pg_ctl reload     [-D DATADIR] [-s]

reload modu, PostgreSQL sunucu sÃ¼recine SIGHUP sinyali gÃ¶nderir. Bu sinyal sayesinde PostgreSQL, yapÄ±landÄ±rma dosyalarÄ±nÄ± (postgresql.conf, pg_hba.conf vb.) yeniden okur.

Bu yÃ¶ntemle, sunucuyu yeniden baÅŸlatmadan bazÄ± yapÄ±landÄ±rma ayarlarÄ±nÄ± deÄŸiÅŸtirmek mÃ¼mkÃ¼ndÃ¼r. 
Yeniden baÅŸlatma gerektirmeyen ayarlar iÃ§in geÃ§erlidir.

â„¹ï¸ Postgresql.conf iÃ§ersinde karÅŸÄ±sÄ±nda yorum olarak restart gerektiren paremetreler belirtilmiÅŸtir
yada
select * from pg_settings where pending_restart is true .  

âš ï¸ PostgreSQLâ€™i pg_ctl veya baÅŸka bir yÃ¶ntemle baÅŸlatmadan Ã¶nce, sistemin donanÄ±m kaynaklarÄ±na (RAM, CPU, disk tipi, I/O kapasitesi) gÃ¶re postgresql.conf iÃ§indeki bazÄ± temel parametrelerin optimize edilmesi gereklidir. Aksi halde PostgreSQL, varsayÄ±lan ayarlarla Ã§alÄ±ÅŸacaktÄ±r ve bu da gerÃ§ek potansiyelinin Ã§ok altÄ±nda performans anlamÄ±na gelir.
*/

postgres server yapÄ±landÄ±rma
/*--------------------------------------------------------------------
ğŸ”´ Postgresql.conf Server YapÄ±landÄ±rma 
ğŸŒ https://www.postgresql.org/docs/17/runtime-config.html
----------------------------------------------------------------------
Postgres Server yapÄ±landÄ±rmasÄ±nÄ±, data directory bulunanan postgresql.conf Ã¼zerinden gerÃ§ekleÅŸtirilir.


#------------------------------------------------------------------------------
# CONNECTIONS AND AUTHENTICATION
#------------------------------------------------------------------------------

ğŸŒhttps://www.postgresql.org/docs/17/runtime-config-connection.html
ğŸ”¶ BaÄŸlantÄ± AyarlarÄ±
# - Connection Settings -
ğŸ’¥#listen_addresses = 'localhost'         # what IP address(es) to listen on;
                                        # comma-separated list of addresses;
                                        # defaults to 'localhost'; use '*' for all
                                        # (change requires restart)

â„¹ï¸ listen_addresses, hangi internet bacaÄŸÄ±ndan eriÅŸim saÄŸlancak ise onlarÄ± belirtilmelidir. *
ile tÃ¼m internet bacaklarÄ± Ã¼zerinden eriÅŸim olacaktÄ±r.

ğŸ’¥#port = 5432                            # (change requires restart)

ğŸ’¥max_connections = 100                   # (change requires restart) 
#max_connection postgres kaÃ§ adet baÄŸlantÄ± kabul edeceÄŸini belirler
#GREATEST(4 x CPU cores, 100)
â„¹ï¸YÃ¼ksek baÄŸlantÄ± sayÄ±larÄ± ihtiyaÃ§ duyuluyor ise. pooling yapÄ±sÄ± kurgulanmalÄ±

#reserved_connections = 5               # (change requires restart)

alter role kullanÄ±cÄ± with resevered;

#superuser_reserved_connections = 3     # (change requires restart)
# superuser rolÃ¼ne sahip kullanÄ±clar ayrÄ±lan slot
select * from pg_roles;
# â˜¢ï¸ Herkes superuser rolÃ¼nde ise bu reserved slotlarÄ±n anlamÄ±nÄ± olmayacaktÄ±r â˜¢ï¸

# - Authentication -

#authentication_timeout = 1min          # 1s-600s
#kimlik doprulamasÄ±nÄ± gerÃ§ekletirmek gereken maksimum sÃ¼re.
#password_encryption = scram-sha-256    # scram-sha-256 or md5
#kullanÄ±calara tanÄ±mlama parolalarÄ±n ÅŸifrelemede kullanÄ±lacak enrpytion metodunu
create role profelis with password 'profelis';
select * from pg_shadow;

#------------------------------------------------------------------------------
# RESOURCE USAGE (except WAL)
#------------------------------------------------------------------------------

# - Memory -
tablo indekslerin cahcelendiÄŸini memory alanÄ±n limiti

shared_buffers = 128MB                  # min 128kB  ğŸ¯ perfomans

                                        # (change requires restart)
#â„¹ï¸ ramin %25-%40 arasÄ±nda optimal deÄŸer verilebilir.

ğŸ’¥ Tablo istatisteklerinde seq_scan yoÄŸunluk var ise bu parametrenin artÄ±rÄ±lmasÄ±,  donanÄ±msal olarak rami yÃ¼kseltmek sorgu perfomanslarÄ±na bÃ¼yÃ¼k etki edecektir.ğŸ’¥

#huge_pages = try                       # on, off, or try

â„¹ï¸ 512GB > bÃ¼yÃ¼k ramlere sahip sunucularda kullanÄ±mÄ± ayarlanmasÄ± dÃ¼ÅŸÃ¼nÃ¼lebilir.. linux Ã¼zerinde huge_pages ayarlarÄ±n yapÄ±lmasÄ± gerekiyor. veritabanÄ± boyutu , shared_buffer sÄ±ÄŸmadÄ±ÄŸÄ± durumlarda.

                                        # (change requires restart)
#huge_page_size = 0                     # zero for system default
                                        # (change requires restart)
#temp_buffers = 8MB                     # min 800kB

â„¹ï¸temp table kullanÄ±mÄ± iÃ§in ramde allacote edilecek maximum alanÄ± belirtiyor aÅŸmasÄ± durumunda diske yazÄ±lacaktÄ±r.
temp table kullanÄ±mÄ± olan sorgularda sorgu Ã¶zelinde yÃ¼kseltilmesi Ã¶nerilir.

?? Oracle tablespaces  

ğŸš¨ Ram hesaplamasÄ± yapÄ±lÄ±rken en kÃ¶tÃ¼ durumda maximum bu alanÄ±n kullanÄ±lacaÄŸÄ± durum dÃ¼ÅŸÃ¼nÃ¼lmelidir.
connection sayÄ±sÄ± * temp_buffer + shared_buffer < ram size 
â˜¢ï¸ out of memory dolayÄ± postgres kill olarak production ortamÄ±nÄ±n kesintiye uÄŸramasÄ± sonuÃ§lanacaktÄ±r. â˜¢ï¸

#work_mem = 4MB                         # min 64kB ğŸ¯ sorgu perfomansÄ±
â„¹ï¸ Sort operations are used for ORDER BY, DISTINCT, and merge joins. Hash tables are used in hash joins, hash-based aggregation, memoize nodes and hash-based processing of IN subqueries.

SorgularÄ±mÄ±zda bu operasyonlarÄ± kullanÄ±yor isek bu parametreyi sesion bazÄ± ayarlamanÄ±z Ã¶nerilir.
â˜¢ï¸postgres process Ã¶zelinde allocate edebilir. 100*4mb=400mb, 1GB verdiÄŸimiz durumda 100*1GB
=100Gb kullanÄ±labilir duruma gelebilir.â˜¢ï¸

ğŸ’¥Fazla veri yorumlayan sorgularda bu parametre arttÄ±rlmasÄ± Ã¶nerilir.
Sorgunun work_mem ihtiyaÃ§Ä±nÄ± explain analyze komutu ile yada pg_stat_statements
eklentisi Ã¼zerinden takip edileiblirğŸ’¥

alter system work_mem

alter role rapor_kullanicis to   work_mem='1GB' connection 10; 
begin       work_mem

#hash_mem_multiplier = 2.0              # 1-1000.0 multiplier on hash table work_mem
# hash bazlÄ± sorgu planlarÄ±nda daha fazla memory kullanÄ±mÄ± saÄŸlamak iÃ§in.

#maintenance_work_mem = 1GB            # min 64kB
â„¹ï¸ bakÄ±m iÅŸlemlerin daha hÄ±zlÄ± tamamlanmasÄ± iÃ§in yÃ¼kseltilmesi dÃ¼ÅŸÃ¼nÃ¼lmeli.
16 dan Ã¶nce 1GB yÃ¼kseltiymiyor . 16-17 , 4GB 

#autovacuum_work_mem = 128MB               # min 64kB, or -1 to use maintenance_work_mem
otomatik bakim iÅŸlemlerinde autovacuum 

#vacuum_buffer_usage_limit = 2MB   # size of vacuum and analyze buffer access strategy ring;

â„¹ï¸ yeni gelen bir Ã¶zellik. vacuum gerÃ§ekleÅŸirken tablo taramasÄ±nÄ±n ne kadar bÃ¼yÃ¼klÃ¼kte bir buffer pencresinde gerÃ§ekleÅŸiÄŸini belirler. Shared buffer iÃ§erisinde. 

Vacuum sÃ¼recini bu parametrenin â¬†ï¸ hÄ±zlandÄ±rÄ±r â¬‡ï¸ yavaÅŸlatÄ±r .

.bakÄ±m iÅŸlemelerin hÄ±zlÄ± tamamlanmasÄ± iÃ§in bir miktar yÃ¼kseltilmesi shared_buffer gÃ¶re dÃ¼ÅŸÃ¼nebilir.

If the specified size would exceed 1/8 the size of shared_buffers,

# - Cost-Based Vacuum Delay -
â„¹ï¸ vacuum process ince ayarÄ±
#vacuum_cost_delay = 0                  # 0-100 milliseconds (0 disables)
â„¹ï¸ manuel vacuum sÃ¼reÃ§inde sÃ¼rekli bir I/O baskÄ±sÄ± ile Ã§alÄ±ÅŸmaktadÄ±r. autovacuum sÃ¼reclerinde kesikli I/O sÃ¼reci yÃ¼rÃ¼tÃ¼lÃ¼yor. 
â„¹ï¸ Ã§ok kÃ¶tÃ¼ durumda disklere sahip ise, vacuum_cost_delay ile disk Ã¼zerindeki baskÄ± azaltÄ±labilir.
#vacuum_cost_page_hit = 1               # 0-10000 credits
#vacuum_cost_page_miss = 2              # 0-10000 credits
#vacuum_cost_page_dirty = 20            # 0-10000 credits
#vacuum_cost_limit = 200                # 1-10000 credits

# - Background Writer -  
shared_buffer da bulunan dirty_buffer (update,delete,insert iÅŸlemleri) diske yazÄ±lmasÄ±.

#bgwriter_delay = 20ms                 # 10-10000ms between rounds
#bgwriter_lru_maxpages = 1000            # max buffers written/round, 0 disables
bir uyanmada
#bgwriter_lru_multiplier = 4.0          # 0-10.0 multiplier on buffers scanned/round
5 page temizledim, 200ms uyudum geldiÄŸimde 5*2 10 tane temizlyece
10*bgwriter_lru_multiplier, 20 tane  <  bgwriter_lru_maxpages 1000

#bgwriter_flush_after = 512kB           # measured in pages, 0 disables

â„¹ï¸ 1xpage= 8kb,  maksiumum 100 page (veri bloÄŸu) (bgwriter_lru_maxpages )  diske yazÄ±mÄ± gerÃ§ekleÅŸiyor. 100*8kb 

select pg_Size_pretty(100*8096::numeric)

*/

kÃ¼Ã§Ã¼k setler , bgwirter disk Ã¼zerinde  1gb 10sn , 1sn 
bÃ¼yÃ¼k setler , sorgu perfmansÄ±nÄ± olumsuz etkiliyor. 
 
select 'Bir turda maksiumun '||pg_size_pretty(bgwriter_lru_maxpages*"1 saniye iÃ§ersinde tetiklenme"*8096::numeric) || '/s disk veri yazÄ±mÄ± '
from (
select  --100 bgwriter_lru_maxpages , 1000/200 "1 saniye iÃ§ersinde tetiklenme"
--yeni ayarlarÄ±m
200 bgwriter_lru_maxpages , 1000/20 "1 saniye iÃ§ersinde tetiklenme"
) t1 

select * from pg_stat_bgwriter --> maxwritten_clean sayÄ±sÄ± artÄ±ÅŸta ise , dirty buffer temizleme iÅŸi yavaÅŸ kalÄ±yordur.
-- â˜¢ï¸bgwriter Ã§ok yavaÅŸ kaldÄ±ÄŸÄ± durumlarda sorgu perfomanslarÄ±nda ara ara, hiÃ§ yetiÅŸemediÄŸi durumda  keskin ÅŸekilde sorgularda yavaÅŸlama gÃ¶rÃ¼lÃ¼r.â˜¢ï¸ 

/*
#effective_io_concurrency = 1           # 1-1000; 0 disables prefetching
â„¹ï¸ disk donanÄ±mÄ± paralel i/o gÃ¼cÃ¼ne gÃ¶re ayarlanmalÄ±, modern ssd diskler iÃ§in 200 iyi baÅŸlangÄ±Ã§ noktasÄ±dÄ±r. seq taramalarda disk taramalarÄ± hÄ±zlanmasÄ±nda.

# - Worker Processes -
#max_worker_processes = 32               # (change requires restart)
â„¹ï¸ server cpu sayÄ±sÄ±na baÄŸla artÄ±labilir. bu havuzdan background processlerde yararlanÄ±yor.

#max_parallel_workers_per_gather = 8    # limited by max_parallel_workers
â„¹ï¸ aynÄ± anda Ã§alÄ±ÅŸacak paralel iÅŸlem sÃ¼reci
â„¹ï¸ bu parametreyi 0 yapmak paralel sorgu Ã§alÄ±ÅŸmasÄ±nÄ± kapatÄ±r.

#max_parallel_workers = 32		# number of max_worker_processes tha
# can be used in parallel operations

#max_parallel_maintenance_workers = 2   # limited by max_parallel_workers 
â„¹ï¸ bakÄ±m iÅŸlemlerinde aynÄ± anda iki indexe reindex atÄ±lmasÄ± saÄŸlar.

#parallel_leader_participation = on
â˜¢ï¸ parallel artÄ±ÄŸÄ± durumda work_mem, maintenance_workmem deÄŸerleri Ã§arpan olarak artacaktÄ±r.â˜¢ï¸
work_mem 10mb,  bir sorgumda 5 paralelik , bu paralelleri 10mb , 50mb

ACID

#------------------------------------------------------------------------------
# WRITE-AHEAD LOG
#------------------------------------------------------------------------------
-- oralce redo log 
https://www.postgresql.org/docs/17/runtime-config-wal.html

# - Settings -
#wal_level = replica                    # minimal, replica, or logical
                                        # (change requires restart)

â„¹ï¸replica ve logical yapÄ±lmayacak ise minamal yapmak yararlÄ± olur. 
wal Ã¼zerinde replica ve logical replikasyon iÃ§in gerekli igller ekliyor.
soldan -> saÄŸa detaylÄ± wal dosyalarÄ± yazÄ±lÄ±r.


#synchronous_commit = on                # synchronization level;
                                        # off, local, remote_write, remote_apply, or on
										
https://www.percona.com/blog/wp-content/uploads/2020/08/sychronous_commit-1.png
â„¹ï¸ on durumunda kalmasÄ± default olarak yeterlidir. replika edilen nodelarda sorgularda veri sekron gelmesi ÅŸartÄ± aranÄ±yor ise remote_apply ile wal dosyasÄ±nÄ±n replikada oynatÄ±lmasÄ± beklen

remote_write , replikaya yazÄ±ldÄ±ÄŸÄ±n eminiz 
postgres recovery.  
remote_apply,  replika Ã¼zerinde wal dosyasÄ±nÄ±n oyantÄ±ldÄ±ÄŸÄ±ndan eminim.


#wal_buffers = -1                       # min 32kB, -1 sets based on shared_buffers
                                        # (change requires restart)
â„¹ï¸  shared_buffer/32 denk geliyor default ayarda.
16mb-64mb arasÄ±nda ayarlanmasÄ± tavsiye edilir.  

#wal_writer_delay = 200ms               # 1-10000 milliseconds
#wal_writer_flush_after = 1MB           # measured in pages, 0 disables
#wal_skip_threshold = 2MB
#commit_delay = 0                       # range 0-100000, in microseconds
#commit_siblings = 5                    # range 1-1000

# - Checkpoints - checkpointer process  

#checkpoint_timeout = 5min              # range 30s-1d
â„¹ï¸ son checkpoint Ã¼zerinden bu kadar sÃ¼re geÃ§ince tetiklenir.
#checkpoint_completion_target = 0.9     # checkpoint target duration, 0.0 - 1.0
#checkpoint_flush_after = 256kB         # measured in pages, 0 disables
#checkpoint_warning = 30s               # 0 disables
max_wal_size = 50GB -- 
â„¹ï¸ son checkpoint noktasÄ±ndan sonra yazÄ±lan wal boyutu max_wal_size aÅŸtÄ±ÄŸÄ±ndan tetiklenir. Bu boyuttan fazla wal dosyalarÄ± sisteme iade edilir. hard limit deÄŸildir. bu parametreden daha fazla wal tutulabilir dizindeâ—ï¸
â„¹ï¸ checkpoint_timeoutdan tetiklenecek ÅŸekilde artÄ±rÄ±lmasÄ± Ã¶nerilir.

min_wal_size = 1GB , 16mb  en az 5 pg_Wal dosyasÄ± bulunacaktÄ±r.

â„¹ï¸ oluÅŸan wal dosyalarÄ± bu deÄŸerin altÄ±na dÃ¼ÅŸmez iÅŸletim sisteminde yeni dosya oluÅŸturma talebinin azaltÄ±r

# - Archiving -

#archive_mode = on             # enables archiving; off, on, or always
                                # (change requires restart)
â˜¢ï¸ bu parametre aÃ§Ä±ldÄ±ÄŸÄ±nda wal dosyalarÄ± rotasyona uÄŸramasÄ± iÃ§in archive sÃ¼recinin baÅŸarÄ±lÄ± ilerlemesi lazÄ±m aksi durumda pg_wal diski dolduracaktÄ±r.â˜¢ï¸

#archive_library = ''           # library to use to archive a WAL file
                                # (empty string indicates archive_command should
                                # be used)
#archive_command = '/bin/bash'           # command to use to archive a WAL file
                                # placeholders: %p = path of file to archive
                                #               %f = file name only
                                # e.g. 'test ! -f /mnt/server/archivedir/%f && cp %p /mnt/server/archivedir/%f'
								
â„¹ï¸ ortamda archive mode kullanÄ±mÄ± dÃ¼ÅŸÃ¼nÃ¼yorlar ise ileride restart atmamak iÃ§in



#------------------------------------------------------------------------------
# QUERY TUNING
#------------------------------------------------------------------------------

# - Planner Cost Constants -

#seq_page_cost = 1.0			# measured on an arbitrary scale
#random_page_cost = 4.0                 # same scale as above
â„¹ï¸ gÃ¼zel ssd var ise 1.2 - 1.5 arasÄ± deÄŸiÅŸtirilebilir. 

#effective_cache_size = 4GB
â„¹ï¸ (total_system_ram - shared_buffer)*%95 ÅŸeklinde ayarlanÄ±r.
%25 shared_buffer + %75 effective_cache_size = %100 total ram
effective_cache_sizeâ¬‡ï¸ seq_scan â¬†ï¸ index_scan

Sistemde kullanÄ±labilir ram miktarÄ±nÄ± anlamsÄ±na yardÄ±mcÄ± oluyor bu limiti zorlamÄ±yor.

#------------------------------------------------------------------------------
# REPORTING AND LOGGING
#------------------------------------------------------------------------------

# This is used when logging to stderr:
#logging_collector = off		# Enable capturing of stderr, jsonlog,
					# and csvlog into log files. Required
					# to be on for csvlogs and jsonlogs.
					# (change requires restart)
					
â„¹ï¸ on konuma getirilmesi Ã¶nerilir pgdata -> log dizini altÄ±nda loglar toplanÄ±r


#log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'        # log file name pattern,
                                                        # can include strftime() escapes
â„¹ï¸ Ã§ok kÃ¼Ã§Ã¼k log parÃ§alarÄ± olmamasÄ± iÃ§in gÃ¼nlÃ¼k yapÄ±labilir.								'postgresql-%Y-%m-%d.log'  

AynÄ± isimde log dosyasÄ± olduÄŸunda eski dosya silinerek. yeni isimle yazÄ±lÄ±r.
log rotasyonu iÃ§in saÄŸlamak iÃ§in 

'postgresql-%Y-%m-%d.log'   -> 'postgresql-%m-%d.log'  ayarlanabilir. senelik dÃ¶nÄŸÃ¼ olacaktÄ±r.
'postgresql-%a.log' -> mon,thu .. sat bir haftalÄ±k dÃ¶nÄŸÃ¼de loglar tutulacaktÄ±r.

#log_min_duration_statement   (yavaÅŸ Ã§alÄ±ÅŸan sorgu tespiti iÃ§in)
â„¹ï¸ veritabanÄ±nda belirtilen deÄŸerden uzun sÃ¼ren sorgularÄ±n loga dÃ¼ÅŸmesi istendiÄŸi durumda 
Ã¶rn 5dk uzun sÃ¼ren sorgularÄ±n tespitinde kullanÄ±labilir.

Sorgu ortalamalarÄ± pg_stat_statemets , kÃ¼mÃ¼latif 

âš ï¸VeritabanÄ±nda Ã§alÄ±ÅŸan sorgu ortalamasÄ±n altÄ±nda bir deÄŸer ayarlanmasÄ± durumunda sorgularÄ±n Ã§oÄŸunluÄŸu loga dÃ¼ÅŸtÃ¼ÄŸÃ¼ gÃ¶rÃ¼lebilir. Kademeli olarak sorgular iyileÅŸtirildikÃ§e azaltÄ±lmasÄ± tavsiye edilir.

-- pg_audit konusu, imperva !!!
-- log ddl dml konusu 

#log_checkpoints = on  
â„¹ï¸ aÃ§Ä±k olmasÄ± tavsiye edilir checkpointlerin zamandan tetiklendiÄŸinin takibi iÃ§in

#log_connections = off
#log_disconnections = off

â„¹ï¸ gelen ve kapan connectionlarÄ±n takipi iÃ§in Ã¶nemli Ã§ok sÄ±k connection aÃ§Ä±p kapanma durumu var ise baÄŸlantÄ± saÄŸlayan tarafÄ±n pooling ile gelmesi tavsiye edilmelidir.

#log_line_prefix 

â„¹ï¸ log kaydÄ±nda hangi ek bilgilerinin olacaÄŸÄ±nÄ± belirlemede
'%h %u %m [%p]

#log_lock_waits=off 
â„¹ï¸lock durumuna dÃ¼ÅŸen sorgularÄ± tespit etmek iÃ§in

#log_statement none, ddl, mod, all  
DDL,alter,create, drop statements
Mod,delete,update,truncate,insert,copy,execute and prepare
all tÃ¼m aksiyonlarÄ± loga dÃ¼ÅŸmesi saÄŸlanÄ±r.

â„¹ï¸  Ã§alÄ±ÅŸan sorgularÄ±n loga dÃ¼ÅŸmesi istendiÄŸi durumda

#------------------------------------------------------------------------------
# CLIENT CONNECTION DEFAULTS
#------------------------------------------------------------------------------

https://www.postgresql.org/docs/current/tutorial-transactions.html
#zaman aÅŸÄ±mÄ± ayarlarÄ±
#statement_timeout = 0                          # in milliseconds, 0 is disabled
â„¹ï¸ DeÄŸerden uzun sorgularÄ±n cancel olmasÄ± iÃ§in
â—ï¸ERROR:  canceling statement due to statement timeout
â„¹ï¸ bu deÄŸerin ayarlanmasÄ± veritabanÄ± Ã¼zerinde ve uzun sÃ¼re Ã§alÄ±ÅŸan sorgularÄ±n birikmesini engelleyerek sistemin tÄ±kanmasÄ±nÄ± Ã¶nlemeye yardÄ±mcÄ± olacaktÄ±r.
#transaction_timeout = 0                        # in milliseconds, 0 is disabled
â„¹ï¸ DeÄŸerden uzun sÃ¼ren sorgu bloklarÄ±n cancel olmasÄ± iÃ§in 

#lock_timeout = 0                               # in milliseconds, 0 is disabled
â„¹ï¸lock durumunda kalan sorgu iptal olmasÄ± iÃ§in
â—ï¸ERROR:  canceling statement due to lock timeout

#idle_in_transaction_session_timeout = 0        # in milliseconds, 0 is disabled
â„¹ï¸ aÃ§Ä±k transaction bloÄŸunda iÅŸlem yapmadan bekleyen
â—ï¸ERROR:  terminating connection due to idle-in-transaction timeout
â˜¢ï¸ uzun sÃ¼re bu durumda kalan sorgular veritabanÄ±nÄ± snapshotÄ±nÄ± tutacaÄŸÄ±nda vacuum iÅŸlemlerin saÄŸlÄ±klÄ± yapÄ±lmasÄ±nÄ± tÄ±kayabilir.
â˜¢ï¸ pooling uygulamasÄ±nÄ±n bu durumdan haberder olmalÄ± bu durum gerÃ§ekleÅŸtiÄŸinde tekrardan pooling connection saÄŸlamalÄ±.

#idle_session_timeout = 0                       # in milliseconds, 0 is disabled
â„¹ï¸ boÅŸta bekleyen connectionlarÄ±n 
â—ï¸ERROR:  terminating connection due to idle session timeout
â˜¢ï¸ Be wary of enforcing this timeout on connections made through connection-pooling software or other middleware, as such a layer may not react well to unexpected connection closure. It may be helpful to enable this timeout only for interactive sessions, perhaps by applying it only to particular users.
â˜¢ï¸ pooling uygulamasÄ±nÄ±n bu durumdan haberder olmalÄ± bu durum gerÃ§ekleÅŸtiÄŸinde tekrardan pooling connection saÄŸlamalÄ±.

â­•ï¸Uzun sÃ¼ren sorgunun iptali iÃ§in
transaction_timeout 
statement_timeout
lock_timeout
â­•ï¸Uzun sÃ¼re duran baÄŸlantÄ±nÄ±n dÃ¼ÅŸÃ¼mesi iÃ§in
idle_session_timeout (sorgu Ã§alÄ±ÅŸmÄ±yor ve boÅŸta bekliyor ise)  â˜¢ï¸
idle_in_transaction_session_timeout (sorgu Ã§alÄ±ÅŸÄ±yor olsa bile)â˜¢ï¸

# - Locale and Formatting 

#datestyle = 'iso, mdy'  
â„¹ï¸ date tipinde verinin gÃ¶rÃ¼nÃ¼mÃ¼ ay-gÃ¼n-yÄ±l

*/

show datestyle;

select '12-31-2021'::Date 
select '31-12-2021'::date  âš ï¸ hata verecek mdy formatÄ±nda deÄŸil
Ã‡alÄ±ÅŸacak uygulamalar yada geliÅŸtirme yapan kiÅŸilerin bu durumun farkÄ±nda olmalÄ±.

tÃ¼rkiye standartlatÄ±nda dmy , #datestyle = 'iso, mdy'  

begin;
set datestyle = 'iso,dmy';

/*
# - Shared Library Preloading -
#shared_preload_libraries = 'pg_stat_statements'          # (change requires restart)
â„¹ï¸ pg_stat_statement ortamlarÄ±nÄ±zda eklenmesi Ã¶nerilir. Sorgu perfomansÄ± takibi.

09:30 - 10:30
11:00 - 12:00

14:00- 15:00
15:30 -16:30



1ï¸âƒ£Postgresql servera deÄŸiÅŸikliÄŸin geÃ§erli olmasÄ± yeniden baÅŸlatÄ±lmasÄ± gereken parametreler
 # (change requires restart) olarak belirtilmiÅŸ.

pg_ctl restart -D datadizin

Geri kalan deÄŸiÅŸiklerde reload atÄ±lmasÄ± yeterli olacaktÄ±r.
cmd -> pg_ctl reload -D datadizin
sql -> select pg_reload_conf();

alter system set work_mem to '200MB';
select pg_reload_conf();
show work_mem ;
select * from pg_settings   where name like '%work_mem%';


alter  system set shared_buffers to '5GB';
select pg_Reload_Conf();
select * from pg_settings where pending_restart is true ; 

-- planalama yaaprken etkilenen parametlrei gÃ¶rmek iÃ§in 


16:30 




EÄŸitimler hafta iÃ§i 09:30-10:30 / 11:00-12:00 ve 14:00-15:00 /15:30-16:30 saatleri arasÄ±nda gerÃ§ekleÅŸecektir.





































										















































































































